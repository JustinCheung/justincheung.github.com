{"pages":[{"text":"Welcome Welcome to JC's Box! My name is Zhang ShiChao.You can call me Cheung.I was born in 1990s. .. more Resume 基本信息 姓名 张师超 民族 汉 专业 计算机科学与技术 (照 片) 性别 男 学历 本科 毕业学校 河南科技大学(原洛阳工学院) 个人主页 www.zscbb.com 出生年月 1990年07月18日 联系电话 18672353959 籍贯 河南省许昌市 电子邮箱 zsc846551675@126.com 在校表现 入学及毕业时间 2009年9月 政治面貌 中共党员 2013年6月 获得奖项 2013年 校级一等奖学金 英语水平 CET-4 2011年 校级三好学生 担任职务 班长、系学生会学术部长 2010年 校级三等奖学金 编程比赛 2012年5月 河南省大学生ACM编程大赛 铜奖 个人履历 2009.9~2013.6 河南科技大学 学生 2013.7至今 武汉迈酷奇科技有限公司 Java软件工程师及算法工程师 项目经验 时 间 项目名称 描述 2013.7至今 华图在线答题系统(砖题库) tiku.huatu.com 开发环境：windows7/Linux/Mac NetBean集成环境 主要功能：帮助华图建立线上考试测试系统，该系统具有快速练习、专项练习、竞技练习、真题练习、智能组卷以及冲刺练习等模块，并处于不断改进升级中 团队人数：15人 参与情况：用户能力自适应算法开发以及题目自适应算法开发，交卷评估、个人能力值评估以及五大功能模块的服务器接口开发 使用技术:IRT理论模型、Jersey、Mybatis、Mysql、Redis、ActiveMQ、Lucene等 2013.3—2013.5 基于局域网的PKI平台 开发环境：windows7 vc6.0 SQL Server2008 主要功能：模拟PKI公钥管理设施的运作流程，帮助教学科研掌握以RSA加密算法的公钥加密体系以及公钥分发体系 使用技术：RSA加密算法，MFC，SQL数据库技术，socket编程 2012.9—2012.10 超市管理数据挖掘系统 开发环境：windows7 vc6.0 SQL Server2008 主要功能：1.完成超市供销存删的管理系统；2.对数据库中的信息进行数据分析，采用Apriori算法进行分析；3.程序运行的情况保存至日志文件。 使用技术：Apriori算法，MFC，Windows API，SQL数据库技术 2012.3—2012.5 网络黑匣子系统 开发环境：Windows7 VC 6.0 SQL Server2008 主要功能：1.使用C/S架构，实时监测网络中装有客户端的主机信息以及网络中数据包情况；2.查看客户端主机的屏幕实时信息；3.实时查看客户端主机运行的网络进程，比如QQ；4.监控客户端系统的运行历史信息并可生成分析图表；5.出现可疑程序后会发出警报。 使用技术：MFC，Windows API，Socket编程，HOOK技术，网络嗅探技术，SQL数据库技术 完成过程：数据库搭建、网络嗅探模块、屏幕实时检测模块 2012.9-2013.4 非对称密钥获取程序 开发环境：Windows7 VC6.0 主要功能：1.进行大素数计算；2.RSA相关运算的函数。 使用技术：C语言 2011.6—2011.7 超市管理系统 开发环境：Win7 C++ Builder6.0 SQL Server2008 主要功能：1.数据库的设计及其优化；2. 实现超市日常的供销存删等任务。 使用技术：C++ Builder，SQL数据库技术 完成过程：供销功能模块，主界面搭建。","title":"About","tags":"pages","url":"http://www.zscbb.com/pages/about.html"},{"text":"序 ==================== &nbsp&nbsp&nbsp&nbsp很久没有写过文章了，刚开始写下这个题目的时候还是有些许不适应的。不知道想写些什么，更不知道能写些什么。但是，一想起这个话题，立刻往事历历在目。那些誓言、承诺、没有实现的梦想、被现实吞没的青春以及那些年离开的人和事全都一涌而出。 &nbsp&nbsp&nbsp&nbsp浊酒一杯入愁肠，却化作千丝万缕相思泪。此去经年，虽明月常向别时圆，却已相逢无期。安知再聚之时不满头华发，又或作古，此岂非\"此时一别成永诀\"。 &nbsp&nbsp&nbsp&nbsp好吧。好吧。总是要来点正能量的，不然我写的都要抑郁了。那就搬个板凳来围成圈，慢慢听我道来。。。。 1. 毕业百天倒计时 =====================","title":"毕业之后这几年","tags":"生活","url":"http://www.zscbb.com/posts/2016/01/bi-ye-zhi-hou-zhe-ji-nian/"},{"text":"Redis 集群是一个提供在多个Redis间节点间共享数据的程序集.redis3.0以前，只支持主从同步的，如果主的挂了，写入就成问题了。3.0出来后就可以很好帮我们解决这个问题。 目前redis 3.0还不稳定，如果要用在生产环境中，要慎重。 一，redis服务器说明 192.168.10.219 6379 192.168.10.219 6380 192.168.10.219 6381 192.168.10.220 6382 192.168.10.220 6383 192.168.10.220 6384 要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。所有用二台机器，开6个redis进程，模拟6台机器。 二，安装ruby,rubygems # yum -y install gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel gcc-c++ automake autoconf # yum -y install ruby rubygems //安装ruby rubygems //换源 # gem source -l # gem source --remove http://rubygems.org/ # gem sources -a http://ruby.taobao.org/ # gem source -l # gem install redis --version 3.0.0 //安装gem_redis Successfully installed redis-3.0.0 1 gem installed Installing ri documentation for redis-3.0.0... Installing RDoc documentation for redis-3.0.0... 三，安装redis3.0.0 1，安装redis # wget http://download.redis.io/releases/redis-3.0.0.tar.gz # tar -xvzf redis-3.0.0.tar.gz # cd redis-3.0.0 # make && make install # cd src # cp redis-trib.rb /usr/local/bin # mkdir /etc/redis # mkdir /var/log/redis 上述操作要先在二台机器上面都操作好。 2,配置redis [root@slave2 redis-3.0.0]# vim redis.conf //解压的根目录，有redis.conf,做以下修改 port 6379 pidfile /var/run/redis-6379.pid dbfilename dump-6379.rdb appendfilename \"appendonly-6379.aof\" cluster-config-file nodes-6379.conf cluster-enabled yes cluster-node-timeout 5000 appendonly yes 3，copy配置文件，并修改端口 # cp redis.conf /etc/redis/redis-6379.conf # cp redis.conf /etc/redis/redis-6380.conf # cp redis.conf /etc/redis/redis-6381.conf # scp redis.conf 192.168.10.220:/etc/redis/redis-6382.conf # scp redis.conf 192.168.10.220:/etc/redis/redis-6383.conf # scp redis.conf 192.168.10.220:/etc/redis/redis-6384.conf # sed -i \"s/6379/6380/g\" /etc/redis/redis-6380.conf # sed -i \"s/6379/6381/g\" /etc/redis/redis-6381.conf # sed -i \"s/6379/6382/g\" /etc/redis/redis-6382.conf # sed -i \"s/6379/6383/g\" /etc/redis/redis-6383.conf # sed -i \"s/6379/6384/g\" /etc/redis/redis-6384.conf 将配置文件分别copy到二台机器上，并替换端口： # cat redis-6380.conf |awk '{if($0 !~ /&#94;$/ && $0 !~ /#/) {print $0}}' |grep 6380 pidfile /var/run/redis-6380.pid port 6380 dbfilename dump-6380.rdb appendfilename \"appendonly-6380.aof\" cluster-config-file nodes-6380.conf 有5处修改端口的地方 4，启动并查看redis # redis-server /etc/redis/redis-6379.conf > /var/log/redis/redis-6379.log 2>&1 & # redis-server /etc/redis/redis-6380.conf > /var/log/redis/redis-6380.log 2>&1 & # redis-server /etc/redis/redis-6381.conf > /var/log/redis/redis-6381.log 2>&1 & # redis-server /etc/redis/redis-6382.conf > /var/log/redis/redis-6382.log 2>&1 & # redis-server /etc/redis/redis-6383.conf > /var/log/redis/redis-6383.log 2>&1 & # redis-server /etc/redis/redis-6384.conf > /var/log/redis/redis-6384.log 2>&1 & # netstat -tpnl |grep redis tcp 0 0 0.0.0.0:6379 0.0.0.0:* LISTEN 7298/redis-server * tcp 0 0 0.0.0.0:6380 0.0.0.0:* LISTEN 7299/redis-server * tcp 0 0 0.0.0.0:6381 0.0.0.0:* LISTEN 7304/redis-server * tcp 0 0 0.0.0.0:16379 0.0.0.0:* LISTEN 7298/redis-server * tcp 0 0 0.0.0.0:16380 0.0.0.0:* LISTEN 7299/redis-server * tcp 0 0 0.0.0.0:16381 0.0.0.0:* LISTEN 7304/redis-server * tcp 0 0 :::6379 :::* LISTEN 7298/redis-server * tcp 0 0 :::6380 :::* LISTEN 7299/redis-server * tcp 0 0 :::6381 :::* LISTEN 7304/redis-server * tcp 0 0 :::16379 :::* LISTEN 7298/redis-server * tcp 0 0 :::16380 :::* LISTEN 7299/redis-server * tcp 0 0 :::16381 :::* LISTEN 7304/redis-server * [root@slave2 redis]# ll /etc/redis/ 总用量 156 -rw-r--r-- 1 root root 0 4月 30 23:54 appendonly-6379.aof -rw-r--r-- 1 root root 0 5月 1 00:08 appendonly-6380.aof -rw-r--r-- 1 root root 0 5月 1 00:08 appendonly-6381.aof -rw-r--r-- 1 root root 18 5月 1 00:08 dump-6379.rdb -rw-r--r-- 1 root root 18 5月 1 00:08 dump-6380.rdb -rw-r--r-- 1 root root 18 5月 1 00:08 dump-6381.rdb -rw-r--r-- 1 root root 763 5月 1 00:08 nodes-6379.conf -rw-r--r-- 1 root root 763 5月 1 00:08 nodes-6380.conf -rw-r--r-- 1 root root 763 5月 1 00:08 nodes-6381.conf -rw-r--r-- 1 root root 41412 4月 30 23:30 redis-6379.conf -rw-r--r-- 1 root root 41412 4月 30 23:39 redis-6380.conf -rw-r--r-- 1 root root 41412 4月 30 23:39 redis-6381.conf 所有节点都启动成功，并不代表，他们就是集群了。 四，创建集群，并查看 1，创建redis集群 # redis-trib.rb create --replicas 1 192.168.10.219:6379 192.168.10.219:6380 192.168.10.219:6381 192.168.10.220:6382 192.168.10.220:6383 192.168.10.220:6384 2，查看redis集群状态 [root@slave2 redis]# redis-trib.rb check 192.168.10.219:6379 Connecting to node 192.168.10.219:6379: OK Connecting to node 192.168.10.220:6384: OK Connecting to node 192.168.10.219:6381: OK Connecting to node 192.168.10.220:6383: OK Connecting to node 192.168.10.220:6382: OK Connecting to node 192.168.10.219:6380: OK >>> Performing Cluster Check (using node 192.168.10.219:6379) M: d40d9a367c24784b0336c7b80fb4c87337e2cba6 192.168.10.219:6379 slots:5461-10922 (5462 slots) master 1 additional replica(s) S: 5f00f163d0c0a540ea99daf004f55588a802327b 192.168.10.220:6384 slots: (0 slots) slave replicates d40d9a367c24784b0336c7b80fb4c87337e2cba6 S: b3b1a848987b5a87a06888e126d5c9b16f871ff5 192.168.10.219:6381 slots: (0 slots) slave replicates d2eb5a8a77f87888792428aed4692dfb907e7a1d M: d2eb5a8a77f87888792428aed4692dfb907e7a1d 192.168.10.220:6383 slots:10923-16383 (5461 slots) master 1 additional replica(s) M: a8eafe8b19d6a28c034917da13a43ce1230fe870 192.168.10.220:6382 slots:0-5460 (5461 slots) master 1 additional replica(s) S: a87d207204a53ab599bf7f6ffb9d679d0eef4f25 192.168.10.219:6380 slots: (0 slots) slave replicates a8eafe8b19d6a28c034917da13a43ce1230fe870 [OK] All nodes agree about slots configuration. >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. 到这儿，redis集群就配置成功了 五，测试redis集群 # redis-cli -c -p 6379 -h 192.168.10.219 //在219登录 192.168.10.219:6379> set tank tank1 //设置测试值 -> Redirected to slot [4407] located at 192.168.10.220:6382 OK //直接转向到220 6382端口，数据存到了220 6382，不过有点奇怪 192.168.10.220:6382> get tank //可以取到值 \"tank1\" [root@manage redis]# redis-cli -c -p 6383 -h 192.168.10.220 //220机器，6383端口 192.168.10.220:6383> get tank -> Redirected to slot [4407] located at 192.168.10.220:6382 //直接转向220 6382端口 \"tank1\" [root@manage redis]# ps aux |grep redis //查看进程 root 7310 0.2 0.9 137436 9724 pts/0 Sl Apr30 0:09 redis-server *:6382 [cluster] root 7311 0.2 0.9 137436 9776 pts/0 Sl Apr30 0:09 redis-server *:6383 [cluster] root 7316 0.2 0.9 137436 9944 pts/0 Sl Apr30 0:10 redis-server *:6384 [cluster] root 7478 0.0 0.0 103256 812 pts/0 S+ 00:56 0:00 grep redis [root@manage redis]# kill -9 7310 //关闭220 6382端口，看数据会不会丢失 [root@slave2 redis]# redis-trib.rb check 192.168.10.219:6379 //查看集群情况，任何接口都行 Connecting to node 192.168.10.219:6379: OK Connecting to node 192.168.10.220:6384: OK Connecting to node 192.168.10.219:6381: OK Connecting to node 192.168.10.220:6383: OK Connecting to node 192.168.10.219:6380: OK >>> Performing Cluster Check (using node 192.168.10.219:6379) M: d40d9a367c24784b0336c7b80fb4c87337e2cba6 192.168.10.219:6379 slots:5461-10922 (5462 slots) master 1 additional replica(s) S: 5f00f163d0c0a540ea99daf004f55588a802327b 192.168.10.220:6384 slots: (0 slots) slave replicates d40d9a367c24784b0336c7b80fb4c87337e2cba6 S: b3b1a848987b5a87a06888e126d5c9b16f871ff5 192.168.10.219:6381 slots: (0 slots) slave replicates d2eb5a8a77f87888792428aed4692dfb907e7a1d M: d2eb5a8a77f87888792428aed4692dfb907e7a1d 192.168.10.220:6383 slots:10923-16383 (5461 slots) master 1 additional replica(s) M: a87d207204a53ab599bf7f6ffb9d679d0eef4f25 192.168.10.219:6380 slots:0-5460 (5461 slots) master 0 additional replica(s) [OK] All nodes agree about slots configuration. >>> Check for open slots... >>> Check slots coverage... [OK] All 16384 slots covered. //变成，三主二从了 [root@slave2 redis]# redis-cli -c -p 6379 -h 192.168.10.219 //219登录 192.168.10.219:6379> get tank -> Redirected to slot [4407] located at 192.168.10.219:6380 //数据被转到了6380节点了 \"tank1\" 经测试，集群是可用的。","title":"redis cluster 集群 安装 配置 详解","tags":"redis","url":"http://www.zscbb.com/posts/2015/06/redis-cluster-ji-qun-an-zhuang-pei-zhi-xiang-jie/"},{"text":"本文我们将要讨论Java面试中的各种不同类型的面试题，它们可以让雇主测试应聘者的Java和通用的面向对象编程的能力。下面的章节分为上下两篇，第一篇将要讨论面向对象编程和它的特点，关于Java和它的功能的常见问题，Java的集合类，垃圾收集器，第二篇主要讨论异常处理，Java小应用程序，Swing，JDBC，远程方法调用(RMI)，Servlet和JSP。 开始! 面向对象编程（OOP） Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点： 代码开发模块化，更易维护和修改。 代码复用。 增强代码的可靠性和灵活性。 增加代码的可理解性。 面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。 封装 封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。 下面列出了使用封装的一些好处： 通过隐藏对象的属性来保护对象内部的状态。 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。 禁止对象之间的不良交互提高模块化。 参考这个文档获取更多关于封装的细节和示例。 多态 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。 继承 继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。 抽象 抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。 抽象和封装的不同点 抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。 常见的Java问题 1.什么是Java虚拟机？为什么Java被称作是\"平台无关的编程语言\"？ Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 2.JDK和JRE的区别是什么？ Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 3.\"static\"关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ \"static\"关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 4.是否可以在static环境中访问非static变量？ static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 5.Java支持的数据类型有哪些？什么是自动拆装箱？ Java语言支持的8中基本数据类型是： byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。 6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。 Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 8.Java支持多继承么？ 不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 9.接口和抽象类的区别是什么？ Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 也可以参考JDK8中抽象类和接口的区别 10.什么是值传递和引用传递？ 对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。 对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。 Java线程 11.进程和线程的区别是什么？ 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。 12.创建线程有几种不同的方式？你喜欢哪一种？为什么？ 有三种方式可以用来创建线程： 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 13.概括的解释下线程的几种可用状态。 线程在执行过程中，可以处于下面几种状态： 就绪(Runnable):线程准备运行，不一定立马就能开始执行。 运行中(Running)：进程正在执行线程的代码。 等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。 睡眠中(Sleeping)：线程被强制睡眠。 I/O阻塞(Blocked on I/O)：等待I/O操作完成。 同步阻塞(Blocked on Synchronization)：等待获取锁。 死亡(Dead)：线程完成了执行。 14.同步方法和同步代码块的区别是什么？ 在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。 15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 16.什么是死锁(deadlock)？ 两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。 17.如何确保N个线程可以访问N个资源同时又不导致死锁？ 使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。 Java集合类 18.Java集合类框架的基本接口有哪些？ Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有： Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的Collection。 List：有顺序的collection，并且可以包含重复元素。 Map：可以把键(key)映射到值(value)的对象，键不能重复。 19.为什么集合类没有实现Cloneable和Serializable接口？ 集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 20.什么是迭代器(Iterator)？ Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的 迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 21.Iterator和ListIterator的区别是什么？ 下面列出了他们的区别： Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 22.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 23.Java中的HashMap的工作原理是什么？ Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 24.hashCode()和equals()方法的重要性体现在什么地方？ Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。 25.HashMap和Hashtable有什么区别？ HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： HashMap允许键和值是null，而Hashtable不允许键或者值是null。 Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。 一般认为Hashtable是一个遗留的类。 26.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ 下面列出了Array和ArrayList的不同点： Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 27.ArrayList和LinkedList有什么区别？ ArrayList和LinkedList都实现了List接口，他们有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 也可以参考ArrayList vs. LinkedList。 28.Comparable和Comparator接口是干什么的？列出它们的区别。 Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 29.什么是Java优先级队列(Priority Queue)？ PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。 30.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？ 大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。 大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。 31.如何权衡是使用无序的数组还是有序的数组？ 有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 32.Java集合类框架的最佳实践有哪些？ 根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。 使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。 33.Enumeration接口和Iterator接口的区别有哪些？ Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。 34.HashSet和TreeSet有什么区别？ HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 垃圾收集器(Garbage Collectors) 35.Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。 36.System.gc()和Runtime.gc()会做什么事情？ 这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。 37.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。 38.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 39.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。 40.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 41.在Java中，对象什么时候可以被垃圾回收？ 当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 42.JVM的永久代中会发生垃圾回收么？ 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区) 原文链接： javacodegeeks 翻译： ImportNew.com - miracle1919 译文链接： http://www.importnew.com/10980.html [ 转载请保留原文出处、译者和译文链接。]","title":"115个Java面试题和答案——终极列表（上）","tags":"面试","url":"http://www.zscbb.com/posts/2015/04/115ge-javamian-shi-ti-he-da-an-zhong-ji-lie-biao-shang/"},{"text":"上一篇 讨论了面向对象编程和它的特点，关于Java和它的功能的常见问题，Java的集合类，垃圾收集器，本章主要讨论异常处理，Java小应用程序，Swing，JDBC，远程方法调用(RMI)，Servlet和JSP。 异常处理 43.Java中的两种异常类型是什么？他们有什么区别？ Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。 44.Java中Exception和Error有什么区别？ Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。 45.throw和throws有什么区别？ throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 45.异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了) 无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。 46.异常处理完成以后，Exception对象会发生什么变化？ Exception对象会在下一个垃圾回收过程中被回收掉。 47.finally代码块和finalize()方法有什么区别？ 无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 Java小应用程序(Applet) 48.什么是Applet？ java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。 49.解释一下Applet的生命周期 applet可以经历下面的状态： Init：每次被载入的时候都会被初始化。 Start：开始执行applet。 Stop：结束执行applet。 Destroy：卸载applet之前，做最后的清理工作。 50.当applet被载入的时候会发生什么？ 首先，创建applet控制类的实例，然后初始化applet，最后开始运行。 51.Applet和普通的Java应用程序有什么区别？ applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。 进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。 最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。 52.Java applet有哪些限制条件？ 主要是由于安全的原因，给applet施加了以下的限制： applet不能够载入类库或者定义本地方法。 applet不能在宿主机上读写文件。 applet不能读取特定的系统属性。 applet不能发起网络连接，除非是跟宿主机。 applet不能够开启宿主机上其他任何的程序。 53.什么是不受信任的applet？ 不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。 54.从网络上加载的applet和从本地文件系统加载的applet有什么区别？ 当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。 当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。 从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。 55.applet类加载器是什么？它会做哪些工作？ 当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。 当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。 56.applet安全管理器是什么？它会做哪些工作？ applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。 Swing 57.弹出式选择菜单(Choice)和列表(List)有什么区别 Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。 58.什么是布局管理器？ 布局管理器用来在容器中组织组件。 59.滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？ Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。 60.哪些Swing的方法是线程安全的？ 只有3个线程安全的方法： repaint(), revalidate(), and invalidate()。 61.说出三种支持重绘(painting)的组件。 Canvas, Frame, Panel,和Applet支持重绘。 62.什么是裁剪(clipping)？ 限制在一个给定的区域或者形状的绘图操作就做裁剪。 63.MenuItem和CheckboxMenuItem的区别是什么？ CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。 64.边缘布局(BorderLayout)里面的元素是如何布局的？ BorderLayout里面的元素是按照容器的东西南北中进行布局的。 65.网格包布局(GridBagLayout)里面的元素是如何布局的？ GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。 66.Window和Frame有什么区别？ Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。 67.裁剪(clipping)和重绘(repainting)有什么联系？ 当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。 68.事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？ 事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。 69.GUI组件如何来处理它自己的事件？ GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。 70.Java的布局管理器比传统的窗口系统有哪些优势？ Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。 71.Java的Swing组件使用了哪种设计模式？ Java中的Swing组件使用了MVC(视图-模型-控制器)设计模式。 JDBC 72.什么是JDBC？ JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 73.解释下驱动(Driver)在JDBC中的角色。 JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 74.Class.forName()方法有什么作用？ 这个方法用来载入跟数据库建立连接的驱动。 75.PreparedStatement比Statement有什么优势？ PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。 76.什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？ CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStament.prepareCall(); 77.数据库连接池是什么意思？ 像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 远程方法调用(RMI) 78.什么是RMI？ Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。 79.RMI体系结构的基本原则是什么？ RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。 80.RMI体系结构分哪几层？ RMI体系结构分以下几层： 存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。 远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。 传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 81.RMI中的远程接口(Remote Interface)扮演了什么样的角色？ 远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 82.java.rmi.Naming类扮演了什么样的角色？ java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。 83.RMI的绑定(Binding)是什么意思？ 绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。 84.Naming类的bind()和rebind()方法有什么区别？ bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 85.让RMI程序能正确运行有哪些步骤？ 为了让RMI程序能正确运行必须要包含以下几个步骤： 编译所有的源文件。 使用rmic生成stub。 启动rmiregistry。 启动RMI服务器。 运行客户端程序。 86.RMI的stub扮演了什么样的角色？ 远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤： 初始化到包含了远程对象的JVM的连接。 序列化参数到远程的JVM。 等待方法调用和执行的结果。 反序列化返回的值或者是方法没有执行成功情况下的异常。 把值返回给调用者。 87.什么是分布式垃圾回收(DGC)？它是如何工作的？ DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。 88.RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？ RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。 89.解释下Marshalling和demarshalling。 当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。 90.解释下Serialization和Deserialization。 Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 Servlet 91.什么是Servlet？ Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。 92.说一下Servlet的体系结构。 所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。 93.Applet和Servlet有什么区别？ Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。 94.GenericServlet和HttpServlet有什么区别？ GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet。这里有Servlet的例子。 95.解释下Servlet的生命周期。 对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。 96.doGet()方法和doPost()方法有什么区别？ doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。 doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。 97.什么是Web应用程序？ Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。 98.什么是服务端包含(Server Side Include)？ 服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。 99.什么是Servlet链(Servlet Chaining)？ Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 100.如何知道是哪一个客户端的机器正在请求你的Servlet？ ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。看下这里的例子。 101.HTTP响应的结构是怎么样的？ HTTP响应由三个部分组成： 状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。 HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。 主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。 102.什么是cookie？session和cookie有什么区别？ cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别： 无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。 在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。 103.浏览器和Servlet通信使用的是什么协议？ 浏览器和Servlet通信使用的是HTTP协议。 104.什么是HTTP隧道？ HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。 105.sendRedirect()和forward()方法有什么区别？ sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。 106.什么是URL编码和URL解码？ URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 JSP 107.什么是JSP页面？ JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。 108.JSP请求是如何被处理的？ 浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。 109.JSP有什么优点？ 下面列出了使用JSP的优点： JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。 JSP页面可以被预编译。 JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。 开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。 开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 110.什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？ Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在<%@ 和 %>之间的。下面列出了不同类型的Directive： 包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。 页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。 Taglib指令： 用来声明页面中使用的自定义的标签库。 111.什么是JSP动作(JSP action)？ JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作： jsp : include - 当 JSP页面被请求的时候包含一个文件 。 jsp : useBean - 找出或者是初始化 Javabean 。 jsp : setProperty - 设置 JavaBean的属性 。 jsp : getProperty - 获取 JavaBean的属性 。 jsp : forward - 把请求转发到新的页面。 jsp : plugin - 产生特定浏览器的代码。 112.什么是Scriptlets？ JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。 113.声明(Decalaration)在哪里？ 声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。 114.什么是表达式(Expression)？ 【列表很长，可以分上、中、下发布】 JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在<%=和%>这两个标签之间定义的。 115.隐含对象是什么意思？有哪些隐含对象？ JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象： application page request response session exception out config pageContext 你还在看么？哇，这可是一篇关于可用在Java面试中的各种类型问题的非常非常长的文章。 如果你喜欢本文，可以订阅我们的期刊或者是白皮书，我们每周都会更新。 那么，那里会有什么其他的Java面试题呢？在评论中回复我们，我们会在文章中包含它们。祝编码快乐！","title":"115个Java面试题和答案——终极列表（下）","tags":"面试","url":"http://www.zscbb.com/posts/2015/04/115ge-javamian-shi-ti-he-da-an-zhong-ji-lie-biao-xia/"},{"text":"程序员人生之路(强烈推荐，分析的透彻！)，某程序达人的人生感悟，估计没有半个甲子的时间，是绝对不可能感悟出来的。 相对同时刚出校门同学从事其它行业而言优厚的薪水，以及不断学习更新的专业知识不仅仅让你感到生活的充实，更满足了你那不让外人知的虚荣心。在刚出校门的几年中，你经常回头看看被你落在后面的同学们，在内心怜悯他们的同时，你也会对自已天天加班的努力工作感到心里平衡：\"有付出才会有回报\"这句话在那几年中你说的最多，不管是对自已的朋友们还是自已的爱人。第二句最常说的话是对公司的领导：\"不行我就走人！\"，实际上你也真的走过几回。对了，在这几年中，因为你的经济条件不错，你开始买房、开始谈恋爱、结婚、开始有了自已的小孩。有时候你会对自已说再过两年就去买车。当然其中可能有许多大件是需要分期付款的，但你对前途充满了信心，你确信认为这种日子会永远的持续下去，即使不是变得更好的话。 日子总是在这种平淡中一天天的过去，就在那么不经意间，你突然发现自已已经快30岁了，或者已经30了，莫名的，你心里会漫延着一种说不清楚的不安情绪，你好像觉得前途并非像前几年那样变得越来越好，你也忽然发现你以前所瞧不起的同学里好像已经有不少开着车的了，也有几个人住着比你还大的房子，好像房款还是一次付清的，你突然明白你现在的生活比起你的同学来最多是中游偏上了。工作中最让你感到心里不舒服的是，你越来越不敢对你的领导说不了，即使比你来的晚的同事升职或提薪，你也只是在私下与朋友们一起喝酒时才敢发发牢骚，在头的面前你的声间越来越小、笑脸是越来越温柔。 你终于开始迷茫\"再过几年我会是在干什么呢？\"，这句话常常出现在你的心里。 计算机开发工作，是一种以年轻为资本的工作，说句通俗点的话是\"吃青春饭的\"，嗯，这句话好像在一种特别的行业也听到过。 其标志就是一：工作的时间性非常强，一个开发项目被定的时限通常是很紧张的，更有甚者，有些号称开发管理的书里面还非常卑鄙的号召将一个项目切成多个小片，每个小片都定一个叫\"里程碑\"的东东来严格跟踪开发进度，加班加点在其它行业是需要加班工资的，而在开发行业，加班工资好像还没见到几个公司发过，是啊，反正有时间限制着，你干不完我再找你算账.所以开发工作通常有着其它工作所没有的精神上的压力。 一旦一个人步入而立之年，因为家庭和孩子的负担，加上精力上面的衰退，加班工作时间变得越来越少，这点让很多老板们感到：这些人已经老了，不好用了。指示人事部门：\"以后招开发人员限制在30岁以下！\"，相对而言硬件开发会年龄方面限制会稍好一点点，但也是五十步笑百步。还有一个很重要的一点就是：计算机这个烂东东实在是进步的太快了，前两年买的顶级配置电脑，现在怎么看怎么像废品，这还是小事，更可气的是好像每天都需要学习新的知识，刚毕业时只会书本上的PASCAL，学会了用腐蚀的办法来做电路板，一上班就开始学习TURBOC和TANGER2.0，刚刚学会，还没来得及高兴，马上开始学 Borland C＋＋和Protel3.0，好不容易学会了，却发现需要学习VC和Protel98了。单片机也是啊：Z80的指令背的很熟，工作中没来得及用就要学 8031，好好学吧，本来想着这辈子就吃它了，又发现又出来什么PIC、DSP、CPLD、FPGA、ARM等等....这还不包括中间要学一大堆74系列、4000系列、XX系列...IC卡居然里面还有CPU卡..如果学习的知识里每个字都能变成一分钱，我想所有的开发工程师都是腰缠万贯的富翁。 一眼看去，这种日子好像见不到头，年轻时乐此不彼，但现在你一定对自已能坚持到什么时候感到怀疑了。我们都玩过像仙剑奇侠传这样的RPG游戏，刚开始时你只是一个一名不文的少年，随着你去打怪物、捡宝贝、学秘芨，最后终于有一天你会变成一个大英雄！那么你在实际生活中过得比那些小侠们还辛苦，为什么成不了一个生活中的大侠呢？呵呵，原因在这里：因为开发工作是邪门功夫，它虽然可以让你速成的变成小资，但它最大的特点是经验不积累！日新月异的知识更新，让你总是感到自已在退步，你就像在RPG中的主人公，开始时就给了你一把好剑和好盔甲，而且让你的级别很高，但让你的经验不累积，虽然刚开始打小怪物时你觉得自已很爽，但越到后来，你会发现你会死的很惨！比较一下你与其它非开发行业的同学你就可以知道了，例如和你学医的同学比起来。套用岳不群他老人家说华山剑宗和气宗的区别那段话：前十年你比你那些学医的同学收入和地位要好的多，但十年以后你和他基本上各方面都会持平，而二十年以后你的各方面远远不能与你学医的同学相提并论！嗯，你已经开始不笑辟邪剑法了吧。 \"敢问路在何方？路在脚下...\"，不过猴兄和八戒兄这么认为是可以的，你呢？ 总结了许多开发朋友在30岁以后的生活之路，让我们一起看看开发人员\"路在何方？\"那么开发人员在30岁以后都干些什么呢？ 其路一：继续做你这个很有\"前途\"的职业吧！ 偶掰着脚指头仔细数了数，发现还真的有很多朋友在30岁以后还在从事开发工作，我这里说的从事，是指你还需要天天在电脑边上编程序和画电路板，与你手下是否有几个小兵无关，也与你是否头上顶着什么项目经理、主任工程师的帽子无关，只要你还需要亲自开发，你就属于这一类。其中有个年龄最大的朋友是63年的，从事医疗仪器的开发工作，35岁左右还在从事软硬件开发工作的仍有一大堆，分析这些仍然从事开发的朋友，基本上都有以下特点： 1 痴迷工作或者痴迷电脑，晚上八点到十二点的这段时间，基本上是在电脑桌或工作台前渡过的。 2 不喜欢与人交住，朋友很少，常联系的人不超过五个。 3 与朋友交往时谈工作多，但一般不主动谈钱。 4 体型偏胖或偏廋，不在正常区间。 5 无未来计划，对五年后自已生活怎么样、从事什么工作说不清楚。 6 俭省，从不乱花钱。 即使你是还不到30岁的开发人员，你也可以看看自己对以上几条是否符合，是否会在30岁后还从事开发职业，四条疑似，五条以上基本确诊你也是这类型的人。 这些朋友们通常报着过一天是一天的态度生活，到了这个年龄，也不敢再轻易的换工作了，年轻时的锐气慢慢的也消退了。唯一不变的希望是有一天从天上掉下来一大堆钱把自己砸伤。说实在话因为他们的性格所限，基本上可以确定他们以后不可能在职场上获得更好的发展，当个小头头，带几个人开发已经是他们发展的顶点。至于以后的人生之路，不仅他们自己迷茫，可能上帝也正在头痛。 不过像这类朋友，偶很奇怪的发现：他们的小孩都是儿子！不知是偶然还是有什么其它说法。 简单建议：要改变命运，先改变性格：坚持半年晚上不从事工作、游戏及电视，用此时间与人交往，你的人生会有改变。 其路二：转行从事技术支持、行政或生产等工作 还有一些朋友，从事了几年的开发工作，因为自已并非特别的爱好，或者领导上面的强制工作安排，他们转到了技术支持、服务或行政等工作，至少当时从表面上看起来，他们的薪水较开发要少一些，但真正的统计这些人，发现他们之中有半数的人获得了更好的发展，升职为服务部经理或行政经理等职，最历害的一个朋友已升职为总经理助理，进入高层。 这类朋友当时转行通常并非自已志愿，属被逼无奈或者其它原因，但显然，拥有专业知识技术的他们显然在非技术部门中鹤立鸡群，遇到什么事情他们均可从专业的角度提出建言，久而久之，他们获得更多的升职和加薪机会也就不足为奇。 因为不从事开发，所以经验开始积累，这类的职业通常会给你一个很安定的感觉，你到30多岁后会发现这类职业反而比开发工作更容易获得新的工作机会。 简单建议：你如果确定在开发部无法获得很好的发展机会，不妨转到其它几个部门试试，换个活法，钱少点就少点吧，机会多。 其路三：开发管理 如果你现在已经是总工或开发部经理，或者你眼看就有机会被提升为这类职务，那么恭喜你，你走的是从\"弼马温\"到\"斗战胜佛\"这条金光大路，你不仅拥有很高的专业技能，而且很显然，你也有着很强的人际交往能力，你这类人根本不需要对未来有着任何的担心，你在即使一无所有的时候也很容易白手起家。 你这种人算是练辟邪剑法练成了仙，嗯，我无话可说。 你是不是这类人也很容易区别，就像围棋二十岁不称国手终身无望一样，你应该在工作三、四年以后，也就是说二十七岁左右就会发现自已工作中指手划脚的时间比亲自开发的时间要多了，而且大多数这类人在这个年龄手下应该有\"兵\"了，相反的，如果你快30岁了还天天埋头于电脑前编程序和画板子，或者30多岁了你还没升到部门经理（虽然你总是觉得自已很有希望），基本上可以确定你不是这类人。好了，如果你确定你是这类人，那么你唯一的想法就是尽快爬上中层和高层，因为有时候人生偶然性太大，不占住坑的萝卜很有可能被人拔出来！ 简单建议：天天去你的老板家里面拖地和擦桌子！ 其路四：出国或考研 有两个搞开发后出国的朋友，其中一个甚至打工打到了一个小公司总工的位置，数据库和软件方面水平巨牛，但仍感觉心里不踏实，于是将自己工作多年的钱忍痛掏出来，出国费加上机票大概将自已辛苦所攒的银子花完，然后又借了一些钱，在02年身上揣着一万美元跑去了加拿大，在加拿大不停的重复找工作，换工作，然后再找工作的循环，找的工作基本上与计算机无关，不过工资总是在1500加元左右，呵呵，折成人民币与他在国内打工拿的基本上差不多，不过租个地下室就花了300加元，然后吃吃喝喝，再买个电脑上上网这类的，基本每月平均还要倒贴一点。前段时间给我的邮件里说，现在身上花的差不多只有5、6000美元了，准备开个小公司，看看能不能往国内倒腾点东东，做最后一搏。另外一个朋友去澳州，时间稍早一些，先是大概摘了一年多的葡萄，后来总算找了个技术工作，每天的工作是画机械图纸，收入还算不错 将近3000澳元，买了个旧车，也算是过上了资本主义生活。不过前年回来一趟，唯一的感叹就是：在国外拿2000美元的生活，绝对不如在国内拿5000人民币的生活舒服。 也有两个考研的朋友，不过其中一个严格的说不是做开发的出身，偏重于市场方面的工作性质，不过我的朋友里面考研的不多，只好凑两个人说说，一个考研后在北京找了个工作，每个月5、6000元钱，但还是做开发，生活仍然与没考研之前没有任何的改变，前途仍然没见到什么大亮的光，还是搞不清楚以后再干些什么，标准的过一天算一天了。另外一个考研后在大学里面找了个工作，工资虽然比他原来打工少了不少，但毕竟终身有靠，稳定了下来，也算修成了正果，这位哥们心情一放松下来，也开始有时间琢磨着业余时间自已做点什么，好像现在慢慢的也开始有了点眉目。 简单建议：这两条路，对开发人员来说都不算是很好，出国十年前是好事，现在难说，考研能成功转行的概率恐怕也不是很大，多半仍然去搞开发，只不过研究生可以多干几年罢了。 其路五：转行到市场 绞尽脑汁的想想，我所知道的人之中只有两个开发人员去了市场，这两个人都不能说是朋友，认识而已。他们都是主动要求去了市场，结果是这两个人均在市场都是干到一年左右，然后都自已开公司了。呵呵，很奇怪，极高的转行成功率！不过仔细想想，我对这两个人的思路佩服的五体投地。能下决心仍掉每月5、6000元的开发职位，从事一个自已并不熟悉的岗位，每月拿个2000多元＋提成，但提成那是说不清楚的事情，这个决定，只能让人感觉到他们对自已前途清晰的把握和老谋深算的心机。而且他们不去服务不去生产，挖空心思说服领导去市场（市场部门与开发部门通常是一个公司的核心部门，进入其实并不容易），可以说是有着长远的考虑的。有技术了，再与客户交成朋友，马上就会产生很大的机遇应该是正常的事情。 有实力，有心机，也有着很强的决心力，这种人恐怕早在大学毕业时或更早的时候就已经决定了自已的人生之路，他们的每一步路在若干年前早就计划周全，现在看起来：学会技术－＞进入市场－＞寻找商机－＞开公司，一条多么清楚的人生之路。但就像我们上小学中学时，所有人都知道上大学是我们最清楚的人生路一样，最后只有少数人才能真正达到目标（当然，现在扩招的历害是另外一回事，我是说我们那个时候，也就是：\"很久很久以前，当我像你那么大的时候\"）。 简单建议：你若是这类人，我的建议是：...嗯?....那个你.你，你别走啊，我还有个事想请你赞助一下啊..... 其路六：开公司自已干 呵呵，看到这一条，发现你的眼睛已经圆了，你肯定千百次的想过这个事情吧，咳咳，其实我从事开发的时候也是天天梦想着这种事情。总想着过两年找个机会就自已干，这个梦想一年又一年的折磨着你也给着你希望。看看吧，开发后来开公司的还真的不少，里面有成功的也有很多失败的，通常开公司都是几个人合伙开始的，有做技术的，有做市场的，几个人一拍即合、狼狈为奸，共同策划了这一个大活动。一般说来能让这几个人下决心走出这一步，产品肯定是先进的，甚至是国内独一无二的，市场也是很大的，负责市场的那个哥们通常会拍着胸保证可以卖出去，并悄悄地告诉你他在某主管领导是他小舅子的同学的二叔，肯定没问题。于是你们几个人找地点、注册执照、买了几个破桌子，再攒了两台电脑，每个人又凑了几万银子，公司开张了！ 产品很快出来了，市场的哥们也不负重望，有几个客户表示要试用了，一切看起来都是如此的正常，\".......你坐在老板桌前，不停的有人来汇报工作或者找你签字...人进人出中...你又想起公司再穷也不能只有一把椅子的故事.....\"你在梦中笑出声来。 是如此的顺利，你们很快就有单子了，很快的单子让你们凑的那点钱不够了，你们很高兴的每个人又增加了投入，拿出钱时你眼泪汪汪的数着钱说：\"这就是我那生蛋的母鸡啊\"。你们的产品确实不错，市场也经营的很好，客户慢慢的多了起来，单子来的时候一笔接着一笔，你每天都处于兴奋之中，唯一美中不足的是好像客户回款总是会拖一些日子，不过客户给你保证说：过几天，过几天就付给你们，因为回款总是在计划外，所以你们为了资金的流畅运行又凑了一些钱，这个时候你有一些心事了，因为你的存款折上面的数字已经快趋向于零了。\"没事，过两个月等回款了一切都OK了，谁干事业不吃点苦呢？\"你这么安慰着自已又投入到工作中去，资金总是在回款和生产经营费用之间走着一个窄窄的小木桥，你的账上总是没有太多的钱，扩大了的公司规模和许多意外情况，使你又一次、二次、三次的与合作者们再次投入了自已的资金，当然，后来的钱你可能已经是借的了..... 终于有一天，你的会计再一次告诉你，老板啊，账上又没现金了，吃过多次苦头的你终于下决心开始重视资金的运行了，你裁掉了一些不必要的人手，减少了开发的投入，要求市场人员签单的时候必须予付XX%的款，回扣也必须等收过款后再付，同时也开始对产品的生产成本开始进行控制。 时间一天一天的过去，因为竟争对手的产品也对你的产品进行了仿造，你的产品慢慢变得不再先进，市场人员开始埋怨公司的合同资金方面规定太严格，不好签单，生产成本的下降通常也导至产品毛病的增多，客户也开始埋怨你的服务人员不能及时进行服务。 终于有一天，你重新走进了人才交流中心，以前你是来招人的，现在你拿着自已的简历开始寻找一个工作 ...... 公司的成功与否，与产品有关，与市场有关，但更重要的是与资金有关，产品与市场都可以通过资金来弥补，而却没有任何东西可以代替 资金，凡是倒下的公司，99%与资金链的断裂有关。在你决定要开公司以前，先估计一下你公司支持一年所需要的资金数额，包括人工费，生产，场地，广告宣传、市场费用、甚至电、水费等等等等，把你所想到的一切加在一起，得出的值就是..慢..如果你没有实际的开过公司的经验，你需要将此数字乘3，然后就是你开公司一年最少需要的费用，呵呵，公司的实际运营所需要的钱是你想像的3倍以上，你要是不信我也没办法。 简单建议：开公司前最重要的是先确立你后续的资金来源！也就是说钱不够了怎么办？－－－因为你投入的钱肯定会不够的。 其路七:第二职业 这类的朋友有不少,他们没有脱离开发工作,但是在业余时间又不停的接项目或者在卖产品,在单位里面他们显得并不出众,比起其它人来说他们属于最不愿意加班的一类.为此他们白天通常工作很勤奋.这类人也许不一定可以挣很多钱,但平均下来他们一年之中通常都可以比同事们多挣个几万元.有时候比上班拿得还多.但令人疑惑的是,这类人在生活中更加注重稳定,基本上没见到他们跳过蹧,即使私下里面已经开了个小公司,他们通常也不会辞职. 你的旁边有没有这类人呢?分辨他们很容易: --电话很多,而且更愿意来电话时离开办公室找个没人的旮旯通话.神秘兮兮给人一种\"这家伙是不是有二奶啊?\"的感觉的人，通常是这类人。这类人是女性最佳的选择对象：很顾家，不象那些富人容易花心，而比起一般人来说，他们收入相对要高得多。但总结了一下几位这类的开发朋友：也得出了一个令人沮丧的结论：这种人通常个子不高，体形类似桶状..... 简单建议：这好像是开发人员最佳的出路了，但比较丰厚的收入通常让这类人不愿意去冒风险....到现在为止我所认识的这类人还没有一个真正算是成功的。 好了，虽然偶的经历远远说不上丰富，也没有什么成功之处可以自满的，但或许因为比其它朋友痴长了几岁，见过的人可能会稍多一些，所 以斗胆写出了以上的一些文字，让您掉牙了。 下面是偶走过开发这条路上总结出来的一点心得，你可以不看，但看了就千万别把嘴咧的太大： 一、不管是给别人打工还是自已干，都要全心全意的工作，因为你所做的任何一点工作都会让自已的人生多一点筹码，这一点最最重要!这样的例子我至少可以举出两起，优秀的开发人员被其它新公司挖走，并给一定的股份，成为新公司的股东的例子。当时与这样的开发人员一个部门同时工作或更早工作的有许多人，他们平时经常偷点懒，能少干点工作就少干点，有时候还笑话那个平时努力工作的人傻，几年过去了，究竟谁比谁傻？ 二、多与市场人员交朋友，你接触他们时可能总会觉得他们知识比你少，甚至素质比你低，可能比你还有点黄。但实际上他们比你更懂这个社会！参加到他们这个圈子中去，和他们一起赌赌钱、一起聊聊天、一起洗洗桑拿、一起.....你会通过他们接触到另外一个世界。 三、机会远比钱重要，挣不挣钱在年轻时并不是特别重要！不论是在实际生活中还是在网上或其它地方，如果有机会参与到除本职工作外的一些项目或产品的开发中（包括你的朋友拉你去做点小生意之类的非开发性质的工作），那怕是帮忙的性质，也要积极介入，至少你会交到很多的朋友，这样你的人生会多出很多的机会。 本文转载于 SmartSoft论坛，喜欢的就转载吧！","title":"程序员人生规划［转］","tags":"杂记","url":"http://www.zscbb.com/posts/2014/07/cheng-xu-yuan-ren-sheng-gui-hua-zhuan/"},{"text":"万维网25岁了，作为探讨\"互联网未来\"的一部分，皮尤研究中心询问了一群科技行业专家对10年后的互联网的想法。他们的回答道出了一个深度互连、远远超越国界的世界。 皮尤向专业人士抛出了一个开放式问题，让他们预测2025年的互联网会在人们的生活中扮演什么角色，会对社会、经济和政治进程产生怎样的影响。\"不管好坏，你觉得2025年互联网对人类最大的影响会是什么?\"皮尤问道。它询问的专业人士有研究人员、企业家、作家、开发者等等。 以下是来自\"2025年数字生活\"概况的回答精选。详情可浏览皮尤网站上的报告全文。 1.无形的信息 麻省理工学院高级研究科学家大卫·克拉克(David Clark)：\"设备们将越来越多地拥有自己的通信模式，自己的‘社交网络'，它们通过这种网络来分享和聚合信息，承担自动化的控制和激活。渐渐地，人类将处于一个决策由一系列活跃的协同操作的设备作出的世界。互联网(以及计算机为媒介的通信)将变得更加无处不在，但不那么显眼。在某种程度上，它将融入我们所有活动所处的情境。\" 2.可穿戴技术的潜力 加州大学伯克利分校软件开发者亚伦·罗伯茨(Aron Roberts)：\"未来很可能会出现各种各样的可穿戴设备，家居和办公室也会有各式的传感器，它们能够帮助我们不断地改变生活方式，及早检测针对疾病风险而不只是疾病本身。我们可能将能够逐日甚至是逐个小时调整药物治疗和生活方式，因而日渐减员的医疗服务系统反而能够大大提升治疗效果。\" 3.\"Ubernet\" 拥有40年数字通信从业经验的大卫·休斯(David Hughes)：\"通过Ubernet，地球上的70多亿人迟早都会‘互连'，连接至特定的地点。这会使得国家对人们的生活的控制力下降。当地球上的每一个人都能够相互触及，进行双向通讯，国家对地理边界内的每一个人的控制力会开始下降。\" 4.全民教育 谷歌首席经济学家哈尔·瓦里安(Hal Varian)：\"互联网对世界最大的影响将会是人人都能触及所有的人类知识。现在，世界上最聪明的人很有可能在印度或者中国的农田中劳作。让那个人以及数以百万那样的人得到教育将会对人类的发展产生深远的影响。廉价移动设备将会全球普及，像可汗学院(Khan Academy)这样的教育工具也将让每一个人都能用到。这会对提高人类的整体文化程度和计算能力产生巨大的影响，全球人口的知识面和教育程度将得到提升。\" 5.日常的黑暗现实 TopEditor国际媒介服务公司CEO卢埃林·克里埃尔(Llewellyn Kriel)：\"互联网上的一切一切都将明码标价。网络恐怖主义将变得司空见惯。个人隐私和信息保密都将成为历史。网络‘疾病'——精神上的、身体上的、社交上的、成瘾的——将侵袭大量的家庭和社区，并跨境蔓延。数字鸿沟将会扩大并恶化到各国或者联合国等国际组织都无法控制的地步。这将加剧富国与穷国的两极分化。全球化公司将会利用这一点。数字犯罪网络将成为新的现实。恐怖行动，不管是组织发起的还是个人发起的，都将成为日常现实。世界将变得越来越不安全，只有个人技能和洞见才能保护个人。\" 6.更加精明的政府 南阿肯色州大学副教授保罗·巴比特(Paul Babbitt)：\"政府在将互联网应用于政治控制和社会管制上将变得高效得多。也就是说过滤工具将变得越来越有价值，越来越重要，高效实用的过滤工具将能够对其服务收费。人们也将乐于以众多网站普遍存在的开放性换取更加结构化、更加规范的环境。\" 7.地缘政治 德克萨斯农工大学传播副教授兰迪·克鲁弗(Randy Kluver)：\"互联网最被忽视的影响在于地缘政治。鲜少专家研究这个问题，但数字媒体的兴起给国与国之间的关系带来的重大影响。部分非常重要的维度包括跨国政治运动的发展，虚拟国家的出现，数字外交努力的影响，信息在削弱国家权力上的角色(想想维基百科)，以及……网络冲突的发展。\" 8.生于线上 谷歌副总裁温特·瑟夫(Vint Cerf)：\"未来将会有更多的公民权和信息共享。为了适应数字通信与存储经济学，商业模式将发生改变。我们最终可能会实现网络选举，但前提是我们要有非常强大的认证体制。隐私问题必须得到改善，企业在保留了用户哪些信息上也需要提高透明度。更多的公司将生于线上，从一开始就面向全球市场。大型开放式网络课程将成为重要的创收来源。\"","title":"未来十年互联网发展趋势","tags":"web","url":"http://www.zscbb.com/posts/2014/05/wei-lai-shi-nian-hu-lian-wang-fa-zhan-qu-shi/"},{"text":"1. 概论 在过去的近十年的时间里，面向对象编程大行其道。以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。 孰不知，在面向对象产生之前，在面向对象思想产生之前，函数式编程已经有了数十年的历史。 那么，接下来，就让我们回顾这个古老又现代的编程模型，让我们看看究竟是什么魔力将这个概念，将这个古老的概念，在21世纪的今天再次拉入了我们的视野。 2. 什么是函数式编程 在 维基百科 中，已经对函数式编程有了很详细的介绍。 那我们就来摘取一下Wiki上对Functional Programming的定义： In computer science , functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data. 简单地翻译一下，也就是说 函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念 。 接下来，我们就来剖析下函数式编程的一些特征。 3. 从并发说开来 说来惭愧，我第一个真正接触到函数式编程，要追溯到两年以前的《 Erlang程序设计 》，我们知道Erlang是一个支持高并发，有着强大容错性的函数式编程语言。 因为时间太久了，而且一直没有过真正地应用，所以对Erlang也只是停留在一些感性认识上。在我眼里，Erlang对高并发的支持体现在两方面，第一， Erlang对轻量级进程的支持 （请注意此处进程并不等于操作系统的进程，而只是Erlang内部的一个单位单元），第二， 就是变量的不变性 。 4. 变量的不变性 在《 Erlang程序设计 》一书中，对变量的不变性是这样说的，Erlang是目前唯一变量不变性的语言。具体的话我记不清了，我不知道是老爷子就是这么写的，还是译者的问题。我在给这本书写书评的时候吹毛求疵地说： 我对这句话有异议，切不说曾经的Lisp，再到如今的F#都对赋值操作另眼相看，低人一等。单说如今的Java和C#，提供的final和readonly一样可以支持变量的不变性，而这个唯一未免显得有点太孤傲了些。 让我们先来看两段程序，首先是我们常见的一种包含赋值的程序： class Account: def __init__ ( self , balance ): self . balance = balance def desposit ( self , amount ): self . balance = self . balance + amount return self . balance def despositTwice ( self ): self . balance = self . balance * 2 return self . balance if __name__ == '__main__' : account = Account ( 100 ) print ( account . desposit ( 10 )) print ( account . despositTwice ()) 这段程序本身是没有问题的，但是我们考虑这样一种情况，现在有多个进程在同时跑这一个程序，那么程序就会被先desposit 还是先 despositTwice所影响。 但是如果我们采用这样的方式： def makeAccount(balance): global desposit global despositTwice def desposit(amount): result = balance + amount return result def despositTwice(): result = balance * 2 return result def dispatch(method): return eval(method) return dispatch if __name__ == '__main__': handler = makeAccount(100) print(handler('desposit')(10)) print(handler('despositTwice')()) 这时我们就会发现，无论多少个进程在跑，因为我们本身没有赋值操作，所以都不会影响到我们的最终结果。 但是这样也像大家看到的一样，采用这样的方式没有办法保持状态。 这也就是我们在之前概念中看到的无状态性。 5. 再看函数式编程的崛起 既然已经看完了函数式编程的基本特征，那就让我们来想想数十年后函数式编程再次崛起的幕后原因。 一直以来，作为函数式编程代表的Lisp，还是Haskell，更多地都是在大学中，在实验室中应用，而很少真的应用到真实的生产环境。 先让我们再来回顾一下伟大的摩尔定律： 1、 集成电路 芯片上所集成的电路的数目，每隔18个月就翻一番。 2、 微处理器 的性能每隔18个月提高一倍，而价格下降一半。 3、用一个美元所能买到的 电脑 性能，每隔18个月翻两番。 一如摩尔的预测，整个信息产业就这样飞速地向前发展着，但是在近年，我们却可以发现摩尔定律逐渐地失效了，芯片上元件的尺寸是不可能无限地缩小的，这就意味着芯片上所能集成的电子元件的数量一定会在某个时刻达到一个极限。那么当技术达到这个极限时，我们又该如何适应日益增长的计算需求，电子元件厂商给出了答案，就是多核。 多核并行程序设计就这样被推到了前线，而命令式编程天生的缺陷却使并行编程模型变得非常复杂，无论是信号量，还是锁的概念，都使程序员不堪其重。 就这样，函数式编程终于在数十年后，终于走出实验室，来到了真实的生产环境中，无论是冷门的Haskell，Erlang，还是Scala，F#，都是函数式编程成功的典型。 6. 函数式编程的第一型 我们知道，对象是面向对象的第一型，那么函数式编程也是一样，函数是函数式编程的第一型。 我们在函数式编程中努力用函数来表达所有的概念，完成所有的操作。 在面向对象编程中，我们把对象传来传去，那 在函数式编程中，我们要做的是把函数传来传去，而这个，说成术语，我们把他叫做高阶函数 。 那我们就来看一个高阶函数的应用，熟悉js的同学应该对下面的代码很熟悉，让哦我们来写一个在电子电路中常用的滤波器的示例代码。 def Filt(arr,func): result = [] for item in arr: result.append(func(item)) return result def MyFilter(ele): if ele < 0 : return 0 return ele if __name__ == '__main__': arr = [-5,3,5,11,-45,32] print('%s' % (Filt(arr,MyFilter))) 哦，之前忘记了说，什么叫做高阶函数，我们给出定义： 在 数学 和 计算机科学 中， 高阶函数 是至少满足下列一个条件的 函数 : 接受一个或多个函数作为输入 输出一个函数 那么，毫无疑问上面的滤波器，就是高阶函数的一种应用。 在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。 让我们看看，变量只是一个名称，在上面的代码中，我们可以这样重写主函数： if __name__ == '__main__': arr = [-5,3,5,11,-45,32] func = MyFilter print('%s' % (Filt(arr,func))) 当然，我们还可以把程序更精简一些，利用函数式编程中的利器，map,filter和reduce : if __name__ == '__main__': arr = [-5,3,5,11,-45,32] print('%s' % (map(lambda&nbsp;x : 0 if x&lt;0 else&nbsp;x ,arr))) 这样看上去是不是更赏心悦目呢？ 这样我们就看到了，函数是我们编程的基本单位。 7. 函数式编程的数学本质 忘了是谁说过：一切问题，归根结底到最后都是数学问题。 编程从来都不是难事儿，无非是细心，加上一些函数类库的熟悉程度，加上经验的堆积，而真正困难的，是如何把一个实际问题，转换成一个数学模型。这也是为什么微软，Google之类的公司重视算法，这也是为什么数学建模大赛在大学计算机系如此被看重的原因。 先假设我们已经凭借我们良好的数学思维和逻辑思维建立好了数学模型，那么接下来要做的是如何把数学语言来表达成计算机能看懂的程序语言。 这里我们再看在第四节中，我们提到的赋值模型，同一个函数，同一个参数，却会在不同的场景下计算出不同的结果，这是在数学函数中完全不可能出现的情况， f(x) = y ，那么这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。 这也是赋值模型与数学模型的不兼容之处。而 函数式编程取消了赋值模型，则使数学模型与编程模型完美地达成了统一 8. 函数式编程的抽象本质 相信每个程序员都对抽象这个概念不陌生。 在面向对象编程中，我们说， 类是现实事物的一种抽象表示。那么抽象的最大作用在我看来就在于抽象事物的重用性 ，一个事物越具体，那么他的可重用性就越低，因此，我们再打造可重用性代码，类，类库时，其实在做的本质工作就在于提高代码的抽象性。而再往大了说开来， 程序员做的工作，就是把一系列过程抽象开来，反映成一个通用过程 ，然后用代码表示出来。 在面向对象中，我们把事物抽象。而在函数式编程中，我们则是在将函数方法抽象，第六节的滤波器已经让我们知道，函数一样是可重用，可置换的抽象单位。 那么我们说 函数式编程的抽象本质则是将函数也作为一个抽象单位，而反映成代码形式，则是高阶函数 。 9.状态到底怎么办 我们说了一大堆函数式编程的特点，但是我们忽略了，这些都是在理想的层面，我们回头想想第四节的变量不变性，确实，我们说，函数式编程是无状态的，可是在我们现实情况中，状态不可能一直保持不变，而状态必然需要改变，传递，那么我们在函数式编程中的则是将其保存在函数的参数中，作为函数的附属品来传递。 ps：在Erlang中，进程之间的交互传递变量是靠\"信箱\"的收发信件来实现，其实我们想一想，从本质而言，也是将变量作为一个附属品来传递么！ 我们来看个例子，我们在这里举一个求x的n次方的例子，我们用传统的命令式编程来写一下： def expr(x,n): result = 1 for i in range(1,n+1): result = result * x return result if __name__ == '__main__': print(expr(2,5)) 这里，我们一直在对result变量赋值，但是我们知道，在函数式编程中的变量是具有不变性的，那么我们为了保持result的状态，就需要将result作为函数参数来传递以保持状态： def expr(num,n): if n==0: return 1 return num*expr(num,n-1) if __name__ == '__main__': print(expr(2,5)) 呦，这不是递归么！ 10. 函数式编程和递归 递归是函数式编程的一个重要的概念，循环可以没有，但是递归对于函数式编程却是不可或缺的。 在这里，我得承认，我确实不知道我该怎么解释递归为什么对函数式编程那么重要。我能想到的只是递归充分地发挥了函数的威力，也解决了函数式编程无状态的问题。（如果大家有其他的意见，请赐教） 递归其实就是将大问题无限地分解，直到问题足够小。 而递归与循环在编程模型和思维模型上最大的区别则在于： 循环是在描述我们该如何地去解决问题。 递归是在描述这个问题的定义。 那么就让我们以斐波那契数列为例来看下这两种编程模型。 先说我们最常见的递归模型，这里，我不采用动态规划来做临时状态的缓存，只是说这种思路： def Fib(a): if a==0 or a==1: return 1 else: return Fib(a-2)+Fib(a-1) 递归是在描述什么是斐波那契数列，这个数列的定义就是一个数等于他的前两项的和，并且已知Fib(0)和Fib(1)等于1。而程序则是用计算机语言来把这个定义重新描述了一次。 那接下来，我们看下循环模型： def Fib(n): a=1 b=1 n = n - 1 while n > 0: temp=a a=a+b b=temp n = n-1 return b 这里则是在描述我们该如何求解斐波那契数列，应该先怎么样再怎么样。 而我们明显可以看到，递归相比于循环，具有着更加良好的可读性。 但是，我们也不能忽略，递归而产生的StackOverflow，而赋值模型呢？我们懂的，函数式编程不能赋值，那么怎么办？ 11. 尾递归，伪递归 我们之前说到了递归和循环各自的问题，那怎么来解决这个问题，函数式编程为我们抛出了答案，尾递归。 什么是尾递归，用最通俗的话说： 就是在最后一部单纯地去调用递归函数 ，这里我们要注意\"单纯\"这个字眼。 那么我们说下尾递归的原理， 其实尾递归就是不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间。 这样的话，占用的栈空间就是常数阶的了。 在看尾递归代码之前，我们还是先来明确一下递归的分类，我们将 递归分成\"树形递归\"和\"尾递归\"，什么是树形递归，就是把计算过程逐一展开，最后形成的是一棵树状的结构 ，比如之前的斐波那契数列的递归解法。 那么我们来看下斐波那契尾递归的写法： def Fib(a,b,n): if n==0: return b else: return Fib(b,a+b,n-1) 这里看上去有些难以理解，我们来解释一下：传入的a和b分别是前两个数，那么每次我都推进一位，那么b就变成了第一个数，而a+b就变成的第二个数。 这就是尾递归。其实我们想一想，这不是在描述问题，而是在寻找一种问题的解决方案，和上面的循环有什么区别呢？我们来做一个从尾递归到循环的转换把！ 最后返回b是把，那我就先声明了，b=0 要传入a是把，我也声明了，a=1 要计算到n==0是把，还是循环while n!=0 每一次都要做一个那样的计算是吧，我用临时变量交换一下。temp=b ; b=a+b;a=temp。 那么按照这个思路一步步转换下去，是不是就是我们在上面写的那段循环代码呢？ 那么这个尾递归，其实本质上就是个\"伪递归\"， 您说呢？ 既然我们可以优化，对于大多数的函数式编程语言的编译器来说，他们对尾递归同样提供了优化，使尾递归可以优化成循环迭代的形式，使其不会造成堆栈溢出的情况。 12. 惰性求值与并行 第一次接触到惰性求值这个概念应该是在Haskell语言中，看一个最简单的惰性求值，我觉得也是最经典的例子： 在Haskell里，有个repeat关键字，他的作用是返回一个无限长的List，那么我们来看下： take 10 (repeat 1); 就是这句代码，如果没有了惰性求值，我想这个进程一定会死在那里，可是结果却是很正常，返回了长度为10的List，List里的值都是1。这就是惰性求值的典型案例。 我们看这样一段简单的代码： def getResult(): a = getA() //Take a long time b = getB() //Take a long time c = a + b 这段代码本身很简单，在命令式程序设计中，编译器（或解释器）会做的就是逐一解释代码，按顺序求出a和b的值，然后再求出c。 可是我们从并行的角度考虑，求a的值是不是可以和求b的值并行呢？也就是说，直到执行到a+b的时候我们编译器才意识到a和b直到现在才需要，那么我们双核处理器就自然去发挥去最大的功效去计算了呢！ 这才是惰性求值的最大威力。 当然，惰性求值有着这样的优点也必然有着缺点，我记得我看过一个例子是最经典的： def Test(): print('Please enter a number:') a = raw_input() 可是这段代码如果惰性求值的话，第一句话就不见得会在第二句话之前执行了。 13. 函数式编程总览 我们看完了函数式编程的特点，我们想想函数式编程的应用场合。 数学推理 并行程序 那么我们总体地说，其实函数式编程最适合地还是解决局部性的数学小问题，要让函数式编程来做CRUD，来做我们传统的逻辑性很强的Web编程，就有些免为其难了。 就像如果要用Scala完全取代今天的Java的工作，我想恐怕效果会很糟糕。而让Scala来负责底层服务的编写，恐怕再合适不过了。 而在一种语言中融入多种语言范式，最典型的C#。在C# 3.0中引入Lambda表达式，在C# 4.0中引入声明式编程，我们某些人在嘲笑C#越来越臃肿的同时，却忽略了，这样的语法糖，带给我们的不仅仅是代码书写上的遍历，更重要的是编程思维的一种进步。 好吧，那就让我们忘记那些C#中Lambda背后的实现机制，在C#中，还是在那些更纯粹地支持函数式编程的语言中，尽情地去体验函数式编程带给我们的快乐把！","title":"[转]函数式编程","tags":"scala","url":"http://www.zscbb.com/posts/2014/05/zhuan-han-shu-shi-bian-cheng/"},{"text":"这两周， 比特币 （bitcoin）的价格 大幅上涨 ，我也凑热闹关注了一阵。 首先说明，我对比特币所知甚少，从未参与过生产/交易，对它的了解仅限于新闻报道和维基百科，但我有一些不成熟的想法。 看着比特币的价格节节上升，我就在想，它有什么用？ 想来想去，我突然悟到，比特币的最佳用途是转移资产！ 假设我有100万人民币，需要转移到美国，比特币是最方便的方法。我在国内市场上用人民币买入比特币，然后立刻转手在美国市场上卖出，将所得的美元转入美国银行账户，就一切OK了。 整个过程只要点几下鼠标就行了，非常方便快捷，不需要任何其他手续或证明文件。而且，比特币是24小时连续交易，不要手续费，成本几乎为零。保密性也非常好，中国政府和美国政府都不会察觉这笔交易，更不要提追踪了。 唯一的风险是，持仓期间价格下跌。但要是买入后立即抛出，价格波动幅度应该不会太大。另外，比特币的价格是全球统一的，中国市场和美国市场几乎没有价差，不用担心汇兑风险。 虽然还没有试验过，但是我越想越觉得，这种转移资金的方法可行。 于是，我马上想到第二个问题，如果比特币真的成为资金转移的首选渠道，会发生什么结果？ 它会供不应求！每个人都想买入，所以价格还会不断上涨。比特币总共只有2100万个，它的价格最后很可能会是天价。 但是，我也意识到，任何数字资产其实都可以充当这种高效、快速、低成本的交易中介，只要它被广为接受，且有足够的市场容量和流动性。比特币在这方面只不过反映了数字货币的优势，只是一个代表而已。说实话，如果腾讯公司有足够的公信力，我觉得 Q币 也能起到比特币的作用。 当然，腾讯公司或者任何其他商业公司，都很难让人完全信任，所以Q币取代不了比特币。分布式、不受任何机构或个人控制，正是比特币的一大卖点。 比特币的真正缺点，我现在只想到一个，这也是我想问的第三个问题。 如果比特币的价格不断上涨，意味着什么？ 很简单，没有人会使用比特币！因为持有者只要一直持有，就能享受价格的不断上涨。在比特币的世界，根本不会发生通货膨胀，只会发生通货紧缩。今天一个西瓜是1比特币，明天可能是0.5比特币，一年以后也许会到0.05比特币。只要你一直持有，它的购买力就在不断增加，所以你不会使用/出售比特币，只会囤积它。另一方面，对生产者来说，通货紧缩就是噩梦，它意味着同样的产量换回的货币越来越少。 因此，我得到了一个悖论：比特币的用途是货币，但是它不可能当作货币用。 如果比特币能够克服这个缺点，就好了。如果发行量能够在2100万的基础上，每年固定增加一个百分比（比如5%），那我就会比较肯定，它就是未来人类社会的货币。 不过，谁也没有说比特币是完美无缺的，本质上它只是一种分布式算法，完全可能做出改进，也许不久以后就会有人提出比特币 2.0算法，或者其他数字货币的算法。事实上，我认为最大风险来自这里。 再次声明，我没研究过 比特币协议 ，也没有实际操作过。上面只是我的一点臆测，很可能没有考虑周全，结论也可能是错的，希望与大家共同探讨。 （完）","title":"比特币","tags":"笔记","url":"http://www.zscbb.com/posts/2014/05/bi-te-bi/"},{"text":"前言 将近一周的折腾时间之后终于把我的博客给搭起来了。由于对pelican提供的主题（根据 pelican文档 提示\"themes are created using Jinja2 templates\"）不是很满意。所以就花去大量时间去改写主题以及测试。但是本人对于设计不是很了解，以至于走了很多的弯路。最后在网上看到有一个很好的主题pelican-elegant,正如其名字那样，这是一款高雅的主题，介于这么高大上的主题,并且对于具体怎么设置的除了官方文档外没有什么好的指导文章，所以我觉得有必要介绍一下。 1.在GitHub上申请账号创建工程 GitHub被誉为\"程序员的Facebook\"，如果你还没有 GitHub 账号，那就先去注册一个。 1.1注册GitHub 关于注册我就不多说了，这个只用根据提示一步一步的设置就好了。在这里贴上一张注册页面的图。 1.2在GitHub上创建仓库 现在恭喜你有了GitHub的账号了，接下来就需要新建一个Repository（仓库）。如图所示： 然后进入一个Repository的配置页面。如图所示： 我的仓库之前已经建立过了，所以提示\"名字已经被使用了\"，你可以根据自己的喜好随意设置仓库名。之后的设置默认就可以了。最后\" Create Repository \"。好了，现在我们就有一个仓库了。但是这个仓库还没有域名，接下来我们要为这个仓库设置一个域名。 在仓库页面的左侧有个\" Settings \"选项，选进去。 在\" GitHub Pages \"这栏（我因为已经创建过页面了所以有提示\" Your site is published at ...... \"），点击\" Automatic Page Generator \"，接下来几步一路continue就可以了。 现在你可以休息一下，也可以先接着往下看。因为GitHub Pages第一次配置之后，大概要十分钟才能为它分配域名成功。好了，闲话少说，我们继续本地配置。 2.安装pelican和git等工具 GitHub Pages是静态网页，所以我们所写的网页不能直接放上去。也不能像\" Wordpress \"那样通过后台来添加博文。所以我们需要一个工具来将写好的文章和模板一起来生成一个静态网站。这个工具就是pelican。Peelican官方文档上是这么说的，\" Pelican is a static site generator, written in Python, that requires no database or server-side logic. \"具体的文档，你可以在 http://blog.getpelican.com/ 上深入研究。好了，我们现在不用太深入纠结。 2.1安装pip Pip是一个为了方便安装和管理Python包的一个工具，通俗的的讲就是一个应用管理中心（官方给出的解释是\" A tool for installing and managing Python packages. \"）。 如果你的python是2.X版本的，你需要安装pip。但是3.X版本的似乎不需要安装pip了。具体需不需要安装，你可以在Python的安装目录下的Scripts的文件夹中看看有没有pip。好了，如果你没有pip那就来配置一下吧。 打开终端，输入下边的代码： curl -O http://python-distribute.org/distribute_setup.py sudo python distribute_setup.py curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py sudo python get-pip.py OK，现在pip已经安装成功了，如果你用的是window系统，那你还需要将Python目录下的Scripts放入环境变量中。 2.2安装pelican 哈哈，现在我们有了pip，就开始配置pelican和一些必要的Python Packages了。闲言少叙，书接上文。 接下来我们需要下载pelican、markdown以及beautifulsoup4等Python Packages。你只需要在终端中输入下边代码： sudo pip install pelican sudo pip install markdown sudo pip install beautifulsoup4 2.3 配置git Git怎么安装的在这里不进行赘述了。只是简单地介绍一下配置Git。 参考了GitHub的配置指南，设置好用户名和邮箱（这里的邮箱用的是你注册GitHub的那个邮箱）。 git config --global user.name \"Your Name Here\" git config --global user.email \"your_email@example.com\" git config --global push.default simple 安装ssh公钥 :用你在注册github时用的Email生成一个ssh公钥私钥对: ssh-keygen -t rsa -C \"your_email@example.com\" Enter passphrase (empty for no passphrase): 输入你在github注册时使用的密码 Enter same passphrase again: 再输一次 然后会看到公钥和私钥分别被保存为id_rsa和id_rsa.pub，后者正是我们需要的。打开github网页，在账户设置（Account settings）中找到SSH keys项目，点击添加SSH key(Add SSH key)，把idrsa.pub中的内容复制到网页中的key里面。到此git配置成功！ 3.配置博客 现在开始创建Blog了，创建一个Blog目录并且用命令pelican-quickstart创建一个博客。 mkdir blog cd blog pelican-quickstart 3.1配置pelican-elegant模板 3.2配置插件 3.3开始写博客 后记","title":"GitHub个人博客创建以及配置过程(连载中。。。)","tags":"Web","url":"http://www.zscbb.com/posts/2014/04/githubge-ren-bo-ke-chuang-jian-yi-ji-pei-zhi-guo-cheng-lian-zai-zhong/"},{"text":"Reddit有篇帖子介绍了算法对我们现在生活的重要性，以及哪些算法对现代文明所做贡献最大。如果对算法有所了解，读这篇文章时你可能会问\"作者知道算法为何物吗？\"，或是\"Facebook的‘信息流'(News Feed)算是一种算法吗？\"，如果\"信息流\"是算法，那就可以把所有事物都归结为一种算法。才疏学浅，结合那篇帖子，接下来我试着解释一下算法是什么，又是哪10个算法正在主导我们的世界。 什么是算法？ 简而言之，任何定义明确的计算步骤都可称为算法，接受一个或一组值为输入，输出一个或一组值。(来源：homas H. Cormen, Chales E. Leiserson 《算法导论第3版》) 可以这样理解，算法是用来解决特定问题的一系列步骤(不仅计算机需要算法，我们在日常生活中也在使用算法)。算法必须具备如下3个重要特性： [1] 有穷性。 执行有限步骤后，算法必须中止。 [2] 确切性。 算法的每个步骤都必须确切定义。 [3] 可行性。 特定算法须可以在特定的时间内解决特定问题， 其实，算法虽然广泛应用在计算机领域，但却完全源自数学。实际上，最早的数学算法可追溯到公元前1600年-Babylonians有关求因式分解和平方根的算法。 那么又是哪10个计算机算法造就了我们今天的生活呢？请看下面的表单，排名不分先后： 1.归并排序(MERGE SORT)，快速排序(QUICK SORT)和堆积排序(HEAP SORT) 哪个排序算法效率最高？这要看情况。这也就是我把这3种算法放在一起讲的原因，可能你更常用其中一种，不过它们各有千秋。 归并排序算法，是目前为止最重要的算法之一，是分治法的一个典型应用，由数学家John von Neumann于1945年发明。 快速排序算法，结合了集合划分算法和分治算法，不是很稳定，但在处理随机列阵(AM-based arrays)时效率相当高。 堆积排序，采用优先伫列机制，减少排序时的搜索时间，同样不是很稳定。 与早期的排序算法相比(如冒泡算法)，这些算法将排序算法提上了一个大台阶。也多亏了这些算法，才有今天的数据发掘，人工智能，链接分析，以及大部分网页计算工具。 2. 傅立叶变换和快速傅立叶变换 这两种算法简单，但却相当强大，整个数字世界都离不开它们，其功能是实现时间域函数与频率域函数之间的相互转化。能看到这篇文章，也是托这些算法的福。 因特网，WIFI，智能机，座机，电脑，路由器，卫星等几乎所有与计算机相关的设备都或多或少与它们有关。不会这两种算法，你根本不可能拿到电子，计算机或者通信工程学位。(USA) 3.代克思托演算法 (Dijkstra's algorithm) 可以这样说，如果没有这种算法，因特网肯定没有现在的高效率。只要能以\"图\"模型表示的问题，都能用这个算法找到\"图\"中两个节点间的最短距离。 虽然如今有很多更好的方法来解决最短路径问题，但代克思托演算法的稳定性仍无法取代。 4. RSA非对称加密算法 毫不夸张地说，如果没有这个算法对密钥学和网络安全的贡献，如今因特网的地位可能就不会如此之高。现在的网络毫无安全感，但遇到钱相关的问题时我们必需要保证有足够的安全感，如果你觉得网络不安全，肯定不会傻乎乎地在网页上输入自己的银行卡信息。 RSA算法，密钥学领域最牛叉的算法之一，由RSA公司的三位创始人提出，奠定了当今的密钥研究领域。用这个算法解决的问题简单又复杂：保证安全的情况下，如何在独立平台和用户之间分享密钥。 5. 哈希安全算法(Secure Hash Algorithm) 确切地说，这不是一种算法，而是一组加密哈希函数，由美国国家标准技术研究所首先提出。无论是你的应用商店，电子邮件和杀毒软件，还是浏览器等等，都使用这种算法来保证你正常下载，以及是否被\"中间人攻击\"，或者\"网络钓鱼\"。 6. 整数质因子分解算法(Integer factorization) 这其实是一个数学算法，不过已经广泛应用与计算机领域。如果没有这个算法，加密信息也不会如此安全。通过一系列步骤将，它可以将一个合成数分解成不可再分的数因子。 很多加密协议都采用了这个算法，就比如刚提到的RSA算法。 7. 链接分析算法(Link Analysis) 在因特网时代，不同入口间关系的分析至关重要。从搜索引擎和社交网站，到市场分析工具，都在不遗余力地寻找因特网的正真构造。 链接分析算法一直是这个领域最让人费解的算法之一，实现方式不一，而且其本身的特性让每个实现方式的算法发生异化，不过基本原理却很相似。 链接分析算法的机制其实很简单：你可以用矩阵表示一幅\"图\"，形成本征值问题。本征值问题可以帮助你分析这个\"图\"的结构，以及每个节点的权重。这个算法于1976年由Gabriel Pinski和Francis Narin提出。 谁会用这个算法呢？Google的网页排名，Facebook向你发送信息流时(所以信息流不是算法，而是算法的结果)，Google+和Facebook的好友推荐功能，LinkedIn的工作推荐，Youtube的视频推荐，等等。 普遍认为Google是首先使用这类算法的机构，不过其实早在1996年(Google问世2年前)李彦宏就创建的\"RankDex\"小型搜索引擎就使用了这个思路。而Hyper Search搜索算法建立者马西莫·马奇奥里也曾使用过类似的算法。这两个人都后来都成为了Google历史上的传奇人物。 8. 比例微积分算法(Proportional Integral Derivative Algorithm) 飞机，汽车，电视，手机，卫星，工厂和机器人等等事物中都有这个算法的身影。 简单来讲，这个算法主要是通过\"控制回路反馈机制\"，减小预设输出信号与真实输出信号间的误差。只要需要信号处理，或电子系统来控制自动化机械，液压和加热系统，都需要用到这个算个法。 没有它，就没有现代文明。 9. 数据压缩算法 数据压缩算法有很多种，哪种最好？这要取决于应用方向，压缩mp3，JPEG和MPEG-2文件都不一样。 哪里能见到它们？不仅仅是文件夹中的压缩文件。你正在看的这个网页就是使用数据压缩算法将信息下载到你的电脑上。除文字外，游戏，视频，音乐，数据储存，云计算等等都是。它让各种系统更轻松，效率更高。 10. 随机数生成算法 到如今，计算机还没有办法生成\"正真的\"随机数，但伪随机数生成算法就足够了。这些算法在许多领域都有应用，如网络连接，加密技术，安全哈希算法，网络游戏，人工智能，以及问题分析中的条件初始化。 这个表单并不完整，很多与我们密切相关的算法都没有提到，如机器学习和矩阵乘法。另外，知识有限，如有批漏，还望指正。","title":"[转]主宰计算机的10个算法","tags":"算法","url":"http://www.zscbb.com/posts/2014/03/zhuan-zhu-zai-ji-suan-ji-de-10ge-suan-fa/"},{"text":"虽然天天跟数据打交道，也频繁地使用Excel进行一些简单的数据处理和展示，但长期以来总是小心地避免用Python直接读写Excel文件。通常我都是把数据保存为以TAB分割的文本文件（TSV），再在Excel中进行导入或者直接复制粘贴。 前段时间做一个项目，却不得不使用Python直接生成Excel文件，后来随着需求的变化，还要对已有的Excel文件进行读取。在这个过程中，研究并尝试了一些工具，也走了一些弯路。记录下来，下次再有类似需求的时候就不用漫天遍野地搜索了。 超级无敌大PK 我主要尝试了四种工具，在此并不会给出他们的排名，因为在不同的应用场景下，做出的选择会不同。 XlsxWriter xlrd&xlwt OpenPyXL Microsoft Excel API 介绍 可以创建Excel 2007或更高版本的XLSX文件 即 python-excel ，含 xlrd 、 xlwt 和 xlutils 三大模块，分别提供读、写和其他功能 可以读写Excel 2007 XLSX和XLSM文件 直接通过COM组件与Microsoft Excel进程通信调用其各种功能实现对Excel文件的操作 读 写 修改 .xls .xlsx 大文件 功能 强 弱 一般 超强 速度 快 快 快 超慢 系统 无限制 无限制 无限制 Windows + Excel 适用场景 要创建XLSX文件 不需要读取已有文件 需要实现比较复杂的功能 数据量可能会很大 需要跨平台 要读取XLS或XLSX文件 要生成XLS文件 需要的功能不太复杂 需要跨平台 要处理XLSX文件 需要修改已有文件，或者在写入过程中需要不断修改 需要的功能比较复杂 数据量可能会很大 需要跨平台 需要处理各种文件格式 需要用到特别复杂的功能 在修改文件时，不希望对原有信息造成任何意外破坏 数据量很小，或者愿意等待 仅在Windows中使用 XlsxWriter XlsxWriter 是我最终选择的用于写操作的工具。顾名思义，它只能用来写文件。 这应该是个比较新的项目，在GitHub上看它最早的提交是在2013年1月份。其官方文档中宣称它支持： 100% compatible Excel XLSX files. Full formatting. Merged cells. Defined names. Charts. Autofilters. Data validation and drop down lists. Conditional formatting. Worksheet PNG/JPEG images. Rich multi-format strings. Cell comments. Memory optimisation mode for writing large files. 优点 一、功能比较强 相对而言，这是除Excel自身之外功能最强的工具了。比如我就用到了它提供的：字体设置、前景色背景色、border设置、视图缩放（zoom）、单元格合并、autofilter、freeze panes、公式、data validation、单元格注释、行高和列宽设置等等。 最让我惊奇的是，用它生成的带有单元格注释的Excel文件，不论是Excel 2007还是Excel 2013都可正常打开（下面会提到，这个任务用Excel自身都无法完成）。 二、支持大文件写入 如果数据量非常大，可以启用 constant memory模式 ，这是一种顺序写入模式，得到一行数据就立刻写入一行，而不会把所有的数据都保持在内存中。 缺点 一、不支持读取和修改 作者并没有打算做一个XlsxReader来提供读取操作。不能读取，也就无从修改了。它只能用来创建新的文件。我是利用xlrd把需要的信息读入后，用XlsxWriter创建全新的文件。 另外，即使是创建到一半Excel文件，也是无法读取已经创建出来的内容的（信息应该在，但是并没有相应的接口）。因为它的主要方法是 write 而不是 set 。当你在某个单元格写入数据后，除非你自己保存了相关的内容，否则还是没有办法读出已经写入的信息。从这个角度看，你无法做到读出->修改->写回，只能是写入->写入->写入。 二、不支持XLS文件 XLS是Office 2013或更早版本所使用的格式，是一种二进制格式的文件。XLSX则是用一系列XML文件组成的（最后的X代表了XML）一个压缩包。如果非要创建低版本的XLS文件，就请移步xlwt吧。 三、暂时不支持透视表（Pivot Table） 透视表是非常麻烦的东西，除了自身复杂的结构外，还需要一套数据缓存。我向作者提出了这个需求，不过这是个很难完全实现的功能，我们慢慢期待吧。 xlrd&xlwt 我的程序在第一版的时候，使用 xlwt 创建XLS文件，然后通过 Microsoft Excel API 将其转换为XLSX文件，并写入高级的Data Validation（Excel 2007的Data Validation比Excel 2003要强大不少）和单元格注释。 我的程序最终的版本也依然用 xlrd 从已有的文件中读出所需的信息。 xlrd&xlwt 主要是针对Office 2013或更早版本的XLS文件格式。 优点 一、支持XLS格式 XlsxWriter和OpenPyXL都不支持XLS格式，从这个角度看， xlrd&xlwt 仍然有一定的不可替代性。 缺点 一、对XLSX支持比较差 目前 xlrd 已经可以读取XLSX文件了，有限地支持。至于 xlwt 我没有试验过，估计是够呛。 二、对修改的支持比较差 xlrd和xlwt是两个相对独立的模块，虽然 xlutils 提供方法帮助你把 xlrd.Book 对象复制到 xlwt.Workbook 对象，但跟XlsxWriter类似，后者只是提供write方法，使得你无法很容易地获取当前已经写入的数据并进行有针对性的修改。如果非要这样做，你要不断地保存，然后再用新的 xlrd.Book 对象读取你要的信息，还是比较麻烦的。 三、功能很弱 除了最基本的写入数据和公式，xlwt所提供的功能非常少（Excel 2013本身支持的功能也就很少）。对于读取也是一样的，很多信息在读入时就丢失掉了。 OpenPyXL OpenPyXL 是比较综合的一个工具，能读能写能修改，功能还算可以但也有很大的缺陷。我在中间版本的时候是打算完全依赖它的，但后来发现一个严重的问题就放弃了。 优点 一、能读能写能修改 OpenPyXL的工作模式跟XlsxWriter和xlwt有很大的区别，它用的是getter/setter模式。你可以随时读取某个单元格的内容，并根据其内容进行相应的修改，OpenPyXL会帮你记住每个单元格的状态。 特别需要注意的一点： 虽然它支持修改已有文件，但由于其所支持的功能有限，读入文件时会忽略掉它所不支持的内容，再写入时，这些内容就丢失了。因此使用时一定要慎重。比如下面的缺点中提到它无法读入公式，那如果你修改一个带有公式的文件，保存之后，所有的公式就都没有了。 二、功能还算可以 整体来讲，它所支持的功能介于XlsxWriter和xlwt之间。 缺点 一、不支持XLS 这件事情只能让xlrd和xlwt去做。 二、不支持读取公式 这其实是个不太简单的事情，虽然我没尝试过，但相信xlrd也做不好这件事。 Excel的单元格如果是一个公式，它内部会同时保存公式本身和运算结果的缓存。用OpenPyXL读取单元格内容，它不会告诉你这个单元格的公式是什么，甚至不会告诉你这个单元格存的是公式，它只会拿到这个缓存的运算结果。我本来想利用它判别单元格是不是用了公式，然后做出不同的处理。结果遇到了这个问题，最后只好采取了其他变通的方式去做。 Microsoft Excel API 大部分Windows环境的开发人员都会选择 Microsoft Excel API 。实际上不仅仅是Python，几乎各种语言都有相应的方法使用它，因为核心的逻辑完全是由Microsft Excel自身提供的。语言相关的部分只是负责跟Windows的COM组件进行通信。 在Python中首先需要安装 Python for Windows extensions （ pywin32 ），具体的文档可以查阅 Win32 Modules 和 Python COM 。 当然你还必须要安装某一个版本的Microsoft Office Excel，它内部的DLL负责实际的操作。 优点 一、最大的优点：强大无极限 因为直接与Excel进程通信，你可以做任何在Excel里可以做的事情。 二、文档丰富 MSDN上的文档绝对是世界上最优秀的文档。没有之一。 三、调试方便 你完全可以直接在Excel里面用宏先调试你想要的效果。甚至如果你不清楚怎么用程序实现某个操作，你可以通过宏录制的方法得到该操作的处理代码。 缺点 一、致命的缺点：慢到死 因为需要与Excel进程通信，其效率是非常低的。 如果让Excel窗口可见，随着程序的运行，你可以看到每一句程序所带来的变化，单元格的内容一个一个地改变。如果要写入的数据很多，那速度是无法忍受的。 二、平台限制 目前还没有发现可以在非Windows系统使用它的方法。 另外，基于它的程序能做什么事情，很大程度上依赖于当前系统所安装的Excel版本。不同的版本在功能上有很大的差异，API也会有差异。用起来会比较麻烦。 三、Excel自身bug导致的问题 我刚好发现了其中一个，这和Python没有任何关系，可以完全在Excel中手动复现。在Excel 2007中随便创建一个文件，给某个单元格添加注释，保存。换台电脑，用Excel 2013打开，就会报错，然后注释就消失了。 同样如果你的程序在一台装有Excel 2007的机器上创建一个带有注释的Excel文件，把这个文件拿到Excel 2013中打开也会报错，也看不到注释。反过来也一样。 关于初始化 Excel的com接口的具体细节我就不介绍了，需要的话直接查阅相关的MSDN文档即可。这里只提几个特殊的小问题。 要想得到一个可以操作的excel对象，一般可以有两种方式： import win32com.client excel = win32com . client . Dispatch ( 'Excel.Application' ) import win32com.client excel = win32com . client . DispatchEx ( 'Excel.Application' ) 二者的区别在于，Dispatch方法会试图寻找并复用一个已有的Excel进程（比如你已经在运行着的Excel程序），而DispatchEx则一定会创建一个新的Excel进程。一般情况使用前者就可以了，还能节省一些资源的开销。但也会带来一些麻烦，有一些状态是在一个Excel进程内共享的，你在同进程的其他窗口内操作有可能会影响到Python程序所要进行的处理，导致各种错误。比如当你手动开启的Excel窗口中，某个单元格正处于编辑状态，那Python程序控制的大部分操作都有可能失败（即使它操作的是另一个文件），因为一个Excel进程中无法让两个单元格同时被编辑。 为了避免麻烦，我一般都使用DispatchEx方法。 关于窗口可见 可以让新启动的Excel进程窗口可见，就像你通过双击桌面上的图标启动一样，程序所控制的每一步操作，在这个窗口中都可以观察得到。你也可以同时进行手动的操作，但一旦这样做，很有可能使你的Python程序崩溃。 窗口不可见也会带来一些麻烦，前面说了，通过Python启动的Excel进程跟你直接从桌面打开的Excel进程没有什么区别，在使用Excel的过程中，我们经常会遇到各种弹出的错误、警告或者提示框，这些在用Python处理时也有可能遇到。尤其当你的程序还没完全调试好时。 我一般都会让程序控制的Excel进程在调试过程中可见，正式使用时不可见，通过类似这样的命令（假设你有一个叫做 is_debug 的变量记录当前是否在调试状态）： excel = win32com . client . DispatchEx ( 'Excel.Application' ) if is_debug : excel . Visible = True 关于保存并覆盖已有文件 打开和保存文件的细节不在这里多说了，可以查看MSDN中相关的API介绍，非常详细。这里只说一下在另存为时，如果目标文件已经存在怎么办。Excel的API另存为方法似乎并没有提供参数决定是否直接覆盖同名的目标文件，在窗口操作中，这种情况会弹出一个确认框来让用户决定。我们的程序当然不想这么做，实际上如果你按照上面所说的让窗口不可见，你也就看不到弹出的窗口。 可以把DisplayAlert属性关闭，这样Excel就不会弹出确认窗，而是直接覆盖同名文件。 orig_display_alerts = excel . DisplayAlerts excel . DisplayAlerts = False try : book . SaveAs ( save_as_file_path ) finally : excel . DisplayAlerts = orig_display_alerts 关于结束Excel进程 进程是一种资源，我们申请了资源，在用完之后就必须要释放掉。尤其如果你隐藏了Excel窗口，用户只有查看系统进程，否则无法关闭你所开启的进程。 但是一个Excel进程是可以同时开启多个文件的，这些文件可能是你程序的其他部分开启的，也可能是用户自己开启的。这样你就不能随意地结束Excel进程，否则会影响到其他人或程序的操作。 我一般会在我的处理完成后（关闭了我自己打开或者创建的Excel文件），判断一下当前Excel进程是否还开启着其他的文档，如果没有了才会结束该进程。 number_of_workbooks = excel . Workbooks . Count if number_of_workbooks > 0 : logging . debug ( 'there are still %d workbooks opened in excel process, not quit excel application' , number_of_workbooks ) else : logging . debug ( 'no workbook opened in excel process, quiting excel application instance ...' ) excel . Quit () del excel 关于枚举常量 Excel API中有各种各样的枚举常量，我还没有找到在Python中直接引用这些常亮的方法，目前的办法 是找到所需的常数的值，自己定义这些常数。比如我用到了如下这些枚举常量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class ExcelConstants ( object ): # XlFileFormat Enumeration xlOpenXMLWorkbook = 51 # Open XML Workbook. # XlDVType Enumeration xlValidateList = 3 # Value must be present in a specified list. # XlDVAlertStyle Enumeration xlValidAlertStop = 1 # Stop icon. # Constants Enumeration xlCenter = - 4108 # XlLineStyle enumeration xlContinuous = 1 要想知道某一个枚举常量的数值，可以查阅MSDN中 Excel Enumerations 相关的资料。","title":"用Python读写Excel文件","tags":"程序开发","url":"http://www.zscbb.com/posts/2013/12/python-read-write-excel/"},{"text":"排序算法很多地方都会用到，近期又重新看了一遍算法，并自己简单地实现了一遍，特此记录下来，为以后复习留点材料。 废话不多说，下面逐一看看经典的排序算法： 1. 选择排序 选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。 举个实例来看看： 初始： [38, 17, 16, 16, 7, 31, 39, 32, 2, 11] i = 0: [2 , 17, 16, 16, 7, 31, 39, 32, 38 , 11] (0th [38]<->8th [2]) i = 1: [2, 7 , 16, 16, 17 , 31, 39, 32, 38, 11] (1st [38]<->4th [17]) i = 2: [2, 7, 11 , 16, 17, 31, 39, 32, 38, 16 ] (2nd [11]<->9th [16]) i = 3: [2, 7, 11, 16, 17, 31, 39, 32, 38, 16] ( 无需交换 ) i = 4: [2, 7, 11, 16, 16 , 31, 39, 32, 38, 17 ] (4th [17]<->9th [16]) i = 5: [2, 7, 11, 16, 16, 17 , 39, 32, 38, 31 ] (5th [31]<->9th [17]) i = 6: [2, 7, 11, 16, 16, 17, 31 , 32, 38, 39 ] (6th [39]<->9th [31]) i = 7: [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 ) i = 8: [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 ) i = 9: [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 ) 由例子可以看出，选择排序随着排序的进行（ i 逐渐增大），比较的次数会越来越少，但是不论数组初始是否有序，选择排序都会从 i 至数组末尾进行一次选择比较，所以给定长度的数组，选择排序的比较次数是固定的： 1 + 2 + 3 + …. + n = n * (n + 1) / 2 ，而交换的次数则跟初始数组的顺序有关，如果初始数组顺序为随机，则在最坏情况下，数组元素将会交换 n 次，最好的情况下则可能 0 次（数组本身即为有序）。 由此可以推出，选择排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) （选择排序只需要一个额外空间用于数组元素交换）。 实现代码： /** * Selection Sorting */ SELECTION ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { int len = array . length ; for ( int i = 0 ; i < len ; i ++) { int selected = i ; for ( int j = i + 1 ; j < len ; j ++) { int compare = array [ j ] . compareTo ( array [ selected ] ) ; if ( compare ! = 0 && compare < 0 == ascend ) { selected = j ; } } exchange ( array , i , selected ) ; } } } ) 2. 插入排序 插入排序的基本思想是在遍历数组的过程中，假设在序号 i 之前的元素即 [0..i-1] 都已经排好序，本趟需要找到 i 对应的元素 x 的正确位置 k ，并且在寻找这个位置 k 的过程中逐个将比较过的元素往后移一位，为元素 x \"腾位置\"，最后将 k 对应的元素值赋为 x ，插入排序也是根据排序的特性来命名的。 以下是一个实例，红色 标记的数字为插入的数字，被划掉的数字是未参与此次排序的元素，红色 标记的数字与被划掉数字之间的元素为逐个向后移动的元素，比如第二趟参与排序的元素为 [11, 31, 12] ，需要插入的元素为 12 ，但是 12 当前并没有处于正确的位置，于是我们需要依次与前面的元素 31 、 11 做比较，一边比较一边移动比较过的元素，直到找到第一个比 12 小的元素 11 时停止比较，此时 31 对应的索引 1 则是 12 需要插入的位置。 初始： [11, 31, 12, 5, 34, 30, 26, 38, 36, 18] 第一趟： [11, 31 , 12, 5, 34, 30, 26, 38, 36, 18] （无移动的元素） 第二趟： [11, 12 , 31, 5, 34, 30, 26, 38, 36, 18] （ 31 向后移动） 第三趟： [5 , 11, 12, 31, 34, 30, 26, 38, 36, 18] （ 11, 12, 31 皆向后移动） 第四趟： [5, 11, 12, 31, 34 , 30, 26, 38, 36, 18] （无移动的元素） 第五趟： [5, 11, 12, 30 , 31, 34, 26, 38, 36, 18] （ 31, 34 向后移动） 第六趟： [5, 11, 12, 26 , 30, 31, 34, 38, 36, 18] （ 30, 31, 34 向后移动） 第七趟： [5, 11, 12, 26, 30, 31, 34, 38 , 36, 18] （无移动的元素） 第八趟： [5, 11, 12, 26, 30, 31, 34, 36 , 38, 18] （ 38 向后移动） 第九趟： [5, 11, 12, 18 , 26, 30, 31, 34, 36, 38] （ 26, 30, 31, 34, 36, 38 向后移动） 插入排序会优于选择排序，理由是它在排序过程中能够利用前部分数组元素已经排好序的一个优势，有效地减少一些比较的次数，当然这种优势得看数组的初始顺序如何，最坏的情况下（给定的数组恰好为倒序）插入排序需要比较和移动的次数将会等于 1 + 2 + 3… + n = n * (n + 1) / 2 ，这种极端情况下，插入排序的效率甚至比选择排序更差。因此插入排序是一个不稳定的排序方法，插入效率与数组初始顺序息息相关。一般情况下，插入排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) 。 实现代码： /** * Insertion Sorting */ INSERTION ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { int len = array . length ; for ( int i = 1 ; i < len ; i ++) { T toInsert = array [ i ]; int j = i ; for ( ; j > 0 ; j --) { int compare = array [ j - 1 ] . compareTo ( toInsert ) ; if ( compare == 0 || compare < 0 == ascend ) { break ; } array [ j ] = array [ j - 1 ]; } array [ j ] = toInsert ; } } } ) 3. 冒泡排序 冒泡排序可以算是最经典的排序算法了，记得小弟上学时最先接触的也就是这个算法了，因为实现方法最简单，两层 for 循环，里层循环中判断相邻两个元素是否逆序，是的话将两个元素交换，外层循环一次，就能将数组中剩下的元素中最小的元素\"浮\"到最前面，所以称之为冒泡排序。 照例举个简单的实例吧： 初始状态： [24, 19, 26, 39, 36, 7, 31, 29, 38, 23] 内层第一趟： [24, 19, 26, 39, 36, 7, 31, 29, 23 , 38 ] （ 9th [23]<->8th [38 ） 内层第二趟： [24, 19, 26, 39, 36, 7, 31, 23 , 29 , 38] （ 8th [23]<->7th [29] ） 内层第三趟： [24, 19, 26, 39, 36, 7, 23 , 31 , 29, 38] （ 7th [23]<->6th [31] ） 内层第四趟： [24, 19, 26, 39, 36, 7, 23, 31, 29, 38] （ 7 、 23 都位于正确的顺序，无需交换） 内层第五趟： [24, 19, 26, 39, 7 , 36 , 23, 31, 29, 38] （ 5th [7]<->4th [36] ） 内层第六趟： [24, 19, 26, 7 , 39 , 36, 23, 31, 29, 38] （ 4th [7]<->3rd [39] ） 内层第七趟： [24, 19, 7 , 26 , 39, 36, 23, 31, 29, 38] （ 3rd [7]<->2nd [26] ） 内层第八趟： [24, 7 , 19 , 26, 39, 36, 23, 31, 29, 38] （ 2nd [7]<->1st [19] ） 内层第九趟： [7 , 24 , 19, 26, 39, 36, 23, 31, 29, 38] （ 1st [7]<->0th [24] ） …... 其实冒泡排序跟选择排序比较相像，比较次数一样，都为 n * (n + 1) / 2 ，但是冒泡排序在挑选最小值的过程中会进行额外的交换（冒泡排序在排序中只要发现相邻元素的顺序不对就会进行交换，与之对应的是选择排序，只会在内层循环比较结束之后根据情况决定是否进行交换），所以在我看来，选择排序属于冒泡排序的改进版。 实现代码： /** * Bubble Sorting, it's very similar with Insertion Sorting */ BUBBLE ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { int length = array . length ; int lastExchangedIdx = 0 ; for ( int i = 0 ; i < length ; i ++) { // mark the flag to identity whether exchange happened to false boolean isExchanged = false ; // last compare and exchange happened before reaching index i int currOrderedIdx = lastExchangedIdx > i ? lastExchangedIdx : i ; for ( int j = length - 1 ; j > currOrderedIdx ; j --) { int compare = array [ j - 1 ] . compareTo ( array [ j ] ) ; if ( compare ! = 0 && compare > 0 == ascend ) { exchange ( array , j - 1 , j ) ; isExchanged = true ; lastExchangedIdx = j ; } } // if no exchange happen means array is already in order if ( isExchanged == false ) { break ; } } } } ) 4. 希尔排序 希尔排序的诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题。希尔排序的思想是将一个大的数组\"分而治之\"，划分为若干个小的数组，以 gap 来划分，比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组（对应的，如 gap = 3 ，则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6] ）然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，直至 gap = 1 ，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，解决了插入排序在处理大规模数组时较多移动次数的问题。 具体实例请参照插入排序。 希尔排序是插入排序的改进版，在数据量大的时候对效率的提升帮助很大，数据量小的时候建议直接使用插入排序就好了。 实现代码： /** * Shell Sorting */ SHELL ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { int length = array . length ; int gap = 1 ; // use the most next to length / 3 as the first gap while ( gap < length / 3 ) { gap = gap * 3 + 1 ; } while ( gap >= 1 ) { for ( int i = gap ; i < length ; i ++) { T next = array [ i ]; int j = i ; while ( j >= gap ) { int compare = array [ j - gap ] . compareTo ( next ) ; // already find its position if ( compare == 0 || compare < 0 == ascend ) { break ; } array [ j ] = array [ j - gap ]; j -= gap ; } if ( j ! = i ) { array [ j ] = next ; } } gap /= 3 ; } } } ) 5. 归并排序 归并排序采用的是递归来实现，属于\"分而治之\"，将目标数组从中间一分为二，之后分别对这两个数组进行排序，排序完毕之后再将排好序的两个数组\"归并\"到一起，归并排序最重要的也就是这个\"归并\"的过程，归并的过程中需要额外的跟需要归并的两个数组长度一致的空间，比如需要规定的数组分别为： [3, 6, 8, 11] 和 [1, 3, 12, 15] （虽然逻辑上被划为为两个数组，但实际上这些元素还是位于原来数组中的，只是通过一些 index 将其划分成两个数组，原数组为 [3, 6, 8, 11, 1, 3, 12, 15 ，我们设置三个指针 lo, mid, high 分别为 0,3,7 就可以实现逻辑上的子数组划分）那么需要的额外数组的长度为 4 + 4 = 8 。归并的过程可以简要地概括为如下： 1） 将两个子数组中的元素复制到新数组 copiedArray 中，以前面提到的例子为例，则 copiedArray = [3, 6, 8, 11, 1, 3, 12, 15] ； 2） 设置两个指针分别指向原子数组中对应的第一个元素，假定这两个指针取名为 leftIdx 和 rightIdx ，则 leftIdx = 0 （对应 copiedArray 中的第一个元素 [3] ）， rightIdx = 4 （对应 copiedArray 中的第五个元素 [1] ）； 3） 比较 leftIdx 和 rightIdx 指向的数组元素值，选取其中较小的一个并将其值赋给原数组中对应的位置 i ，赋值完毕后分别对参与赋值的这两个索引做自增 1 操作，如果 leftIdx 或 rigthIdx 值已经达到对应数组的末尾，则余下只需要将剩下数组的元素按顺序 copy 到余下的位置即可。 下面给个归并的具体实例： 第一趟： 辅助数组 [21 , 28, 39 | 35, 38] （数组被拆分为左右两个子数组，以 | 分隔开） [21 , , , , ] （第一次 21 与 35 比较 , 左边子数组胜出， leftIdx = 0 ， i = 0 ） 第二趟： 辅助数组 [21, 28 , 39 | 35, 38] [21 , 28, , , ] （第二次 28 与 35 比较，左边子数组胜出， leftIdx = 1 ， i = 1 ） 第三趟： [21, 28, 39 | 35 , 38] [21 , 28 , 35, , ] （第三次 39 与 35 比较，右边子数组胜出， rightIdx = 0 ， i = 2 ） 第四趟： [21, 28, 39 | 35, 38 ] [21 , 28 , 35 , 38, ] （第四次 39 与 38 比较，右边子数组胜出， rightIdx = 1 ， i = 3 ） 第五趟： [21, 28, 39 | 35, 38] [21 , 28 , 35 , 38 , 39] （第五次时右边子数组已复制完，无需比较 leftIdx = 2 ， i = 4 ） 以上便是一次归并的过程，我们可以将整个需要排序的数组做有限次拆分（每次一分为二）直到分为长度为 1 的小数组为止，长度为 1 时数组已经不用排序了。在这之后再逆序（由于采用递归）依次对这些数组进行归并操作，直到最后一次归并长度为 n / 2 的子数组，归并完成之后数组排序也完成。 归并排序需要的额外空间是所有排序中最多的，每次归并需要与参与归并的两个数组长度之和相同个元素（为了提供辅助数组）。则可以推断归并排序的空间复杂度为 1 + 2 + 4 + … + n = n * ( n + 2) / 4 （忽略了 n 的奇偶性的判断），时间复杂度比较难估，这里小弟也忘记是多少了（囧）。 实现代码： /** * Merge sorting */ MERGE ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { this . sort ( array , 0 , array . length - 1 , ascend ) ; } private < T extends Comparable < T >> void sort ( T [] array , int lo , int hi , boolean ascend ) { // OPTIMIZE ONE // if the substring 's length is less than 20, // use insertion sort to reduce recursive invocation if ( hi - lo < 20 ) { for ( int i = lo + 1 ; i <= hi ; i ++) { T toInsert = array [ i ]; int j = i ; for ( ; j > lo ; j --) { int compare = array [ j - 1 ] . compareTo ( toInsert ) ; if ( compare == 0 || compare < 0 == ascend ) { break ; } array [ j ] = array [ j - 1 ]; } array [ j ] = toInsert ; } return ; } int mid = lo + ( hi - lo ) / 2 ; sort ( array , lo , mid , ascend ) ; sort ( array , mid + 1 , hi , ascend ) ; merge ( array , lo , mid , hi , ascend ) ; } private < T extends Comparable < T >> void merge ( T [] array , int lo , int mid , int hi , boolean ascend ) { // OPTIMIZE TWO // if it is already in right order , skip this merge // since there 's no need to do so int leftEndCompareToRigthStart = array [ mid ] . compareTo ( array [ mid + 1 ] ) ; if ( leftEndCompareToRigthStart == 0 || leftEndCompareToRigthStart < 0 == ascend ) { return ; } @ SuppressWarnings ( \"unchecked\" ) T [] arrayCopy = ( T [] ) new Comparable [ hi - lo + 1 ]; System . arraycopy ( array , lo , arrayCopy , 0 , arrayCopy . length ) ; int lowIdx = 0 ; int highIdx = mid - lo + 1 ; for ( int i = lo ; i <= hi ; i ++) { if ( lowIdx > mid - lo ) { // left sub array exhausted array [ i ] = arrayCopy [ highIdx ++ ]; } else if ( highIdx > hi - lo ) { // right sub array exhausted array [ i ] = arrayCopy [ lowIdx ++ ]; } else if ( arrayCopy [ lowIdx ] . compareTo ( arrayCopy [ highIdx ] ) < 0 == ascend ) { array [ i ] = arrayCopy [ lowIdx ++ ]; } else { array [ i ] = arrayCopy [ highIdx ++ ]; } } } } ) 6. 快速排序 快速排序也是用归并方法实现的一个\"分而治之\"的排序算法，它的魅力之处在于它能在每次partition（排序算法的核心所在）都能为一个数组元素确定其排序最终正确位置（一次就定位准，下次循环就不考虑这个元素了）。 快速排序的partition操作按以下逻辑进行，假定本次排序的数组为arr： 1） 选择一个元素（为了简单起见，就选择本次partition的第一个元素，即arr[0]）作为基准元素，接下来的步骤会为其确定排序完成后最终的位置； 2） 1） 接下来需要遍历[1…n-1]对应的数组元素以帮助找到arr[0]值（以v替代）对应的位置，定义i为当前访问数组的索引，lt为值小于v的最大索引，gt为值大于v的最小索引，那么在遍历过程中，如果发现i指向的值与v相等，则将i值加1，继续下一次比较；如果i指向的值比v小，则将i和lt对应的元素进行交换，然后分别将两个索引加1；如果i指向的值比v大，则将i与gt对应的元素进行交换，然后i自增，gt自减。循环遍历完成（i > gt时结束）之后可以保证[0…lt-1]对应的值都是比v小的，[lt..gt]之间的值都是与v相等的，[gt+1…n-1]对应的值都是比v大的。 3） 分别对[0…lt-1]和[gt+1…n-1]两个子数组进行排序，如此递归，直至子子子数组的长度为0。 下面举个partition的具体实例： 初始（i = 1, lt = 0, gt = 8）： [41, 59, 43, 26, 63, 30, 29, 26, 42]（需要确定位置的为0th[41]） 第一趟（i = 1, lt = 0, gt = 8）： [41, 42, 43, 26, 63, 30, 29, 26, 59]（1st[59] > 41，1st[59]<->8th[42]，gt--） 第二趟（i = 1, lt = 0, gt = 7）： [41, 26, 43, 26, 63, 30, 29, 42, 59]（1st[42] > 41，1st[42]<->7th[26]，gt--） 第三趟（i = 1, lt = 0, gt = 6）： [26, 41, 43, 26, 63, 30, 29, 42, 59]（1st[26] < 41, 1st[26]<->0st[41]，i++, lt++） 第四趟（i = 2, lt = 1, gt = 6）： [26, 41, 29, 26, 63, 30, 43, 42, 59]（2nd[43] > 41，2nd[43]<->6th[29]，gt--） 第五趟（i = 2, lt = 1, gt = 5）： [26, 29, 41, 26, 63, 30, 43, 42, 59]（2nd[29] < 41, 2nd[29]<->1st[41]，i++，lt++） 第六趟（i = 3, lt = 2, gt = 5）： [26, 29, 26, 41, 63, 30, 43, 42, 59]（3rd[26] < 41，3rd[26]<->2nd[41]，i++，lt++） 第七趟（i = 4, lt = 3, gt = 5）： [26, 29, 26, 41, 30, 63, 43, 42, 59] （4th[63] > 41，4th[63]<->5th[30]，gt--） 第八趟（i = 4, lt = 3, gt = 4）： [26, 29, 26, 30, 41, 63, 43, 42, 59]（4th[30] < 41，4th[30]<->3rd[41]，i++，lt++） 可以看出，在一次partition之后，以41为分割线，41左侧皆为比它小的元素，41右侧皆为比它大或相等的元素（当然这个实例比较特殊，没有出现和41相等的元素）。快速排序顾名思义就是排序速度非常快，后面我会放在我机器上跑各个排序方法的时间对比图。值得一提的是JDK中在Arrays工具内中内置的sort方法就是接合插入排序和三路快速排序实现的，有兴趣的同学可以看看JDK的源码。 实现代码： /** * Quick Sorting */ QUICK ( new Sortable () { public < T extends Comparable < T >> void sort ( T [] array , boolean ascend ) { this . sort ( array , 0 , array . length - 1 , ascend ) ; } private < T extends Comparable < T >> void sort ( T [] array , int lo , int hi , boolean ascend ) { if ( lo >= hi ) { return ; } T toFinal = array [ lo ]; int leftIdx = lo ; int rightIdx = hi ; int i = lo + 1 ; while ( i <= rightIdx ) { int compare = array [ i ] . compareTo ( toFinal ) ; if ( compare == 0 ) { i ++ ; } else if ( compare < 0 == ascend ) { exchange ( array , leftIdx ++, i ++) ; } else { exchange ( array , rightIdx --, i ) ; } } // partially sort left array and right array // no need to include the leftIdx - th to rightIdx - th elements // since they are already in its final position sort ( array , lo , leftIdx - 1 , ascend ) ; sort ( array , rightIdx + 1 , hi , ascend ) ; } } ) 这里是我测试时的测试用例，利用了枚举和策略模式的优势，切换排序算法时相对会比较容易。 以下为经典排序算法在我机器上运行的耗时对比图（测试用的随机数组长度为50000），直接截的测试用例的图。","title":"常用排序算法小记","tags":"算法","url":"http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/"},{"text":"问题本身很明确，但不知道起个什么题目好，姑且先这么说吧。 问题描述：现在有一个叫做Rand5的函数，可以生成等概率的[0, 5)范围内的随机整数，要求利用此函数写一个Rand3函数（除此之外，不能再使用任何能产生随机数的函数或数据源），生成等概率的[0, 3)范围内的随机整数。 我第一次遇到这个问题的时候，着实犯了一回傻，自以为是地证明了这个题目是无解的。其实从概率的角度来看，题目的要求就是，利用一个1/5的概率源，通过某种方式产生出1/3的概率输出。我们都知道，概率运算法则有加法和乘法，而在我的记忆中，算法是\"在有限步骤内求解某一问题所使用的一组定义明确的规则\"，算法的一个重要特征就是有穷性，即一个算法必须保证执行有限步之后结束。那么有限多个1/5通过加法和乘法是不可能的到1/3这个数值的，因为加法和乘法都不会给分母带来新的因子，那么分母中的3根本就不可能出现。 然而我忽略了这样一个式子： \\begin{equation*} \\sum_{i=0}&#94;\\infty \\left(\\frac{2}{5}\\right)&#94;i = \\frac{1}{1-\\frac{2}{5}} = \\frac{5}{3} \\end{equation*} 基于这个想法，我们来看看这个算法是什么样子的： def Rand3 (): x = - 1 while not 0 <= x < 3 : x = Rand5 () return x int Rand3 () { int x ; do { x = Rand5 (); } while ( x >= 3 ); return x ; } 算法很简单，x是我们最终要输出的数字，只要它不在[0, 3)范围内，就不断地调用Rand5来更新它。直观地看，算法输出的数字只有0、1、2这三个，而且对任何一个都没有偏袒，那么显然每个数字的概率都是1/3，那让我们来严格地计算一下。 以输出0为例，看看概率是多少。x的第一个有效数值是通过Rand5得到的。Rand5返回0的概率是1/5，如果这事儿发生了，我们就得到了0，否则只有当Rand5返回3或4的时候，我们才有机会再次调用它来得到新的数据。第二次调用Rand5之后，又是有1/5的概率得到0，2/5的概率得到3或4导致循环继续执行下去，如此反复。因此概率的计算公式为： \\begin{equation*} \\begin{array}{rcl} p & = & \\frac{1}{5}+\\frac{2}{5}\\times\\left(\\frac{1}{5}+\\frac{2}{5}\\times\\left(\\frac{1}{5}+\\frac{2}{5}\\times\\left(\\cdots\\right)\\right)\\right) \\\\ & = & \\frac{1}{5}\\times\\sum_{i=0}&#94;\\infty \\left(\\frac{2}{5}\\right)&#94;i \\\\ & = & \\frac{1}{5}\\times\\frac{1}{1-\\frac{2}{5}} \\\\ & = & \\frac{1}{5}\\times\\frac{5}{3} \\\\ & = & \\frac{1}{3} \\end{array} \\end{equation*} 喏，计算表明，Rand3输出0的概率确实是1/3，对于另外两个数字也是一样的。 那么这段代码是不是一个算法呢，它是否满足算法的有穷性呢？我不能确定，虽然它不停机的概率是0，然而这个概率是一个极限值，唉，回去复习极限知识先。 【2013年11月7日添加】今天想到，对于上面那个函数，需要再了解一下它消耗的时间。具体来讲，就是要知道平均每调用一次Rand3，相当于调用了多少次Rand5。根据算法可以知道，Rand3函数执行一次，有3/5的概率是只调用一次Rand5就能停机；刚好调用两次Rand5后停机的概率是(2/5) * (3/5)。类推下去，刚好调用k次Rand5后停机的概率应该是(2/5) &#94; (k-1) * (3/5)。根据这个概率分布，可以计算出停机前Rand5被调用次数的数学期望，即 \\begin{equation*} \\sum_{k=1}&#94;{\\infty}{k\\times p(k)} =\\sum_{k=1}&#94;{\\infty}k \\frac{3}{5} \\left(\\frac{2}{5}\\right)&#94;{k-1} =\\frac{3}{5}\\times\\frac{1}{\\left(1-\\frac{2}{5}\\right)&#94;2} =\\frac{5}{3} \\end{equation*} 可见，Rand3函数每运行一次，平均需要调用1.67次Rand5。 更一般地，当我们依据上述算法，将一种分布的随机信号转换成另外一种随机信号时，如果每消耗m个源信号，就有p的概率可以产生一个目标信号，那么平均来讲，停机前需要使用的源信号数据个数的期望为： \\begin{equation*} \\sum_{k=1}&#94;{\\infty}k\\cdot m\\cdot p\\cdot (1-p)&#94;{k-1}=\\frac{m}{p} \\end{equation*} 【2013年11月7日添加结束】 改变一下题目，如果要求利用Rand5编写Rand7怎么办？很简单，用两个Rand5可以拼出Rand25，然后就用前面的方法即可： def Rand7 (): x = - 1 while not 0 <= x < 21 : x = Rand5 () * 5 + Rand5 () return x % 7 int Rand7 () { int x ; do { x = Rand5 () * 5 + Rand5 (); } while ( x >= 21 ); return x % 7 ; } 【2013年11月7日】可以直接算出，按照这种方法，平均每运行一次Rand7，需要调用Rand5的次数。这里m等于2，p等于21/25，所以最后的结果是50/21，大约是2.38。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https:' == document.location.protocol ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: 'center',\" + \" displayIndent: '0em',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['$','$'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }\" + \" } \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","title":"利用等概率Rand5产生等概率Rand3","tags":"算法","url":"http://www.zscbb.com/posts/2011/08/build-rand3-from-rand5/"}]}