<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="JustinCheung" />
        <meta name="copyright" content="JustinCheung" />


<meta name="keywords" content="算法, Java, 算法, " />

<meta property="og:title" content="常用排序算法小记 "/>
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/" />
<meta property="og:description" content="排序算法很多地方都会用到，近期又重新看了一遍算法，并自己简单地实现了一遍，特此记录下来，为以后复习留点材料。 废话不多说，下面逐一看看经典的排序算法： 1. 选择排序 选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。 举个实例来看看： 初始： [38, 17, 16, 16, 7, 31, 39, 32, 2, 11] i = 0: [2 , 17, 16, 16, 7, 31, 39, 32, 38 , 11] (0th [38]<->8th [2 ..." />
<meta property="og:site_name" content="JC's Box" />
<meta property="og:article:author" content="JustinCheung" />
<meta property="og:article:published_time" content="2013-05-21T00:00:00" />
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用排序算法小记 ">
<meta name="twitter:description" content="排序算法很多地方都会用到，近期又重新看了一遍算法，并自己简单地实现了一遍，特此记录下来，为以后复习留点材料。 废话不多说，下面逐一看看经典的排序算法： 1. 选择排序 选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。 举个实例来看看： 初始： [38, 17, 16, 16, 7, 31, 39, 32, 2, 11] i = 0: [2 , 17, 16, 16, 7, 31, 39, 32, 38 , 11] (0th [38]<->8th [2 ...">

        <title>常用排序算法小记  · JC's Box
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://www.zscbb.com/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://www.zscbb.com/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://www.zscbb.com/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://www.zscbb.com/theme/css/custom.css" media="screen">
        <link rel="shortcut icon" href="http://www.zscbb.com/theme/images/favicon.ico" type="image/x-icon" type="image/png" />
        <link rel="icon" href="http://www.zscbb.com/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link rel="apple-touch-icon" href="http://www.zscbb.com/theme/images/apple-touch-icon.png"  type="image/png" />
        <link rel="apple-touch-icon" sizes="57x57" href="http://www.zscbb.com/theme/images/apple-touch-icon-57x57.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="72x72" href="http://www.zscbb.com/theme/images/apple-touch-icon-72x72.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="76x76" href="http://www.zscbb.com/theme/images/apple-touch-icon-76x76.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="114x114" href="http://www.zscbb.com/theme/images/apple-touch-icon-114x114.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="120x120" href="http://www.zscbb.com/theme/images/apple-touch-icon-120x120.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="144x144" href="http://www.zscbb.com/theme/images/apple-touch-icon-144x144.png" type="image/png" />
        <link rel="apple-touch-icon" sizes="152x152" href="http://www.zscbb.com/theme/images/apple-touch-icon-152x152.png" type="image/png" />
        <link href="http://www.zscbb.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="JC's Box - Full Atom Feed" />
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-50301243-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
    </head>
    <body>
		
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://www.zscbb.com/"><span class=site-name>JC's Box</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://www.zscbb.com">Home</a></li>
                            <li ><a href="http://www.zscbb.com/pages/about.html">About</a></li>
                            <li ><a href="http://www.zscbb.com/categories.html">Categories</a></li>
                            <li ><a href="http://www.zscbb.com/tags.html">Tags</a></li>
                            <li ><a href="http://www.zscbb.com/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://www.zscbb.com/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/"> 常用排序算法小记  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <div class="toc">
<ul>
<li><a href="#1">1. 选择排序</a></li>
<li><a href="#2">2. 插入排序</a></li>
<li><a href="#3">3. 冒泡排序</a></li>
<li><a href="#4">4. 希尔排序</a></li>
<li><a href="#5">5. 归并排序</a></li>
<li><a href="#6">6. 快速排序</a></li>
</ul>
</div>
        </nav>
    </div>
    <div class="span8 article-content">

            
            
<p>排序算法很多地方都会用到，近期又重新看了一遍算法，并自己简单地实现了一遍，特此记录下来，为以后复习留点材料。</p>
<p>废话不多说，下面逐一看看经典的排序算法：</p>
<h1 id="1">1. 选择排序</h1>
<p>选择排序的基本思想是遍历数组的过程中，以 i 代表当前需要排序的序号，则需要在剩余的 [i…n-1] 中找出其中的最小值，然后将找到的最小值与 i 指向的值进行交换。因为每一趟确定元素的过程中都会有一个选择最大值的子流程，所以人们形象地称之为选择排序。</p>
<p>举个实例来看看：</p>
<blockquote>
<p>初始： [38, 17, 16, 16, 7, 31, 39, 32, 2, 11]</p>
<p>i = 0:  [2 , 17, 16, 16, 7, 31, 39, 32, 38 , 11] (0th [38]&lt;-&gt;8th [2])</p>
<p>i = 1:  [2, 7 , 16, 16, 17 , 31, 39, 32, 38, 11] (1st [38]&lt;-&gt;4th [17])</p>
<p>i = 2:  [2, 7, 11 , 16, 17, 31, 39, 32, 38, 16 ] (2nd [11]&lt;-&gt;9th [16])</p>
<p>i = 3:  [2, 7, 11, 16, 17, 31, 39, 32, 38, 16] ( 无需交换 )</p>
<p>i = 4:  [2, 7, 11, 16, 16 , 31, 39, 32, 38, 17 ] (4th [17]&lt;-&gt;9th [16])</p>
<p>i = 5:  [2, 7, 11, 16, 16, 17 , 39, 32, 38, 31 ] (5th [31]&lt;-&gt;9th [17])</p>
<p>i = 6:  [2, 7, 11, 16, 16, 17, 31 , 32, 38, 39 ] (6th [39]&lt;-&gt;9th [31])</p>
<p>i = 7:  [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 )</p>
<p>i = 8:  [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 )</p>
<p>i = 9:  [2, 7, 11, 16, 16, 17, 31, 32, 38, 39] ( 无需交换 )</p>
</blockquote>
<p>由例子可以看出，选择排序随着排序的进行（ i 逐渐增大），比较的次数会越来越少，但是不论数组初始是否有序，选择排序都会从 i 至数组末尾进行一次选择比较，所以给定长度的数组，选择排序的比较次数是固定的： 1 + 2 + 3 + …. + n = n * (n + 1) / 2 ，而交换的次数则跟初始数组的顺序有关，如果初始数组顺序为随机，则在最坏情况下，数组元素将会交换 n 次，最好的情况下则可能 0 次（数组本身即为有序）。</p>
<p>由此可以推出，选择排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) （选择排序只需要一个额外空间用于数组元素交换）。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Selection Sorting </span>
<span class="cm"> */</span>  
<span class="no">SELECTION</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>  
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">int</span> <span class="n">selected</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  
            <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
                <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">selected</span><span class="p">]);</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">!=</span> <span class="mh">0</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                    <span class="n">selected</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>  
                <span class="p">}</span>  
            <span class="p">}</span>

            <span class="n">exchange</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">selected</span><span class="p">);</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<h1 id="2">2. 插入排序</h1>
<p>插入排序的基本思想是在遍历数组的过程中，假设在序号 i 之前的元素即 [0..i-1] 都已经排好序，本趟需要找到 i 对应的元素 x 的正确位置 k ，并且在寻找这个位置 k 的过程中逐个将比较过的元素往后移一位，为元素 x “腾位置”，最后将 k 对应的元素值赋为 x ，插入排序也是根据排序的特性来命名的。</p>
<p>以下是一个实例，红色 标记的数字为插入的数字，被划掉的数字是未参与此次排序的元素，红色 标记的数字与被划掉数字之间的元素为逐个向后移动的元素，比如第二趟参与排序的元素为 [11, 31, 12] ，需要插入的元素为 12 ，但是 12 当前并没有处于正确的位置，于是我们需要依次与前面的元素 31 、 11 做比较，一边比较一边移动比较过的元素，直到找到第一个比 12 小的元素 11 时停止比较，此时 31 对应的索引 1 则是 12 需要插入的位置。</p>
<blockquote>
<p>初始：    [11, 31, 12, 5, 34, 30, 26, 38, 36, 18]</p>
<p>第一趟： [11, 31 , 12, 5, 34, 30, 26, 38, 36, 18] （无移动的元素）</p>
<p>第二趟： [11, 12 , 31, 5, 34, 30, 26, 38, 36, 18] （ 31 向后移动）</p>
<p>第三趟： [5 , 11, 12, 31, 34, 30, 26, 38, 36, 18] （ 11, 12, 31 皆向后移动）</p>
<p>第四趟： [5, 11, 12, 31, 34 , 30, 26, 38, 36, 18] （无移动的元素）</p>
<p>第五趟： [5, 11, 12, 30 , 31, 34, 26, 38, 36, 18] （ 31, 34 向后移动）</p>
<p>第六趟： [5, 11, 12, 26 , 30, 31, 34, 38, 36, 18] （ 30, 31, 34 向后移动）</p>
<p>第七趟： [5, 11, 12, 26, 30, 31, 34, 38 , 36, 18] （无移动的元素）</p>
<p>第八趟： [5, 11, 12, 26, 30, 31, 34, 36 , 38, 18] （ 38 向后移动）</p>
<p>第九趟： [5, 11, 12, 18 , 26, 30, 31, 34, 36, 38] （ 26, 30, 31, 34, 36, 38 向后移动）</p>
</blockquote>
<p>插入排序会优于选择排序，理由是它在排序过程中能够利用前部分数组元素已经排好序的一个优势，有效地减少一些比较的次数，当然这种优势得看数组的初始顺序如何，最坏的情况下（给定的数组恰好为倒序）插入排序需要比较和移动的次数将会等于 1 + 2 + 3… + n = n * (n + 1) / 2 ，这种极端情况下，插入排序的效率甚至比选择排序更差。因此插入排序是一个不稳定的排序方法，插入效率与数组初始顺序息息相关。一般情况下，插入排序的时间复杂度和空间复杂度分别为 O(n2 ) 和 O(1) 。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Insertion Sorting </span>
<span class="cm"> */</span>  
<span class="no">INSERTION</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>  
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
            <span class="no">T</span> <span class="n">toInsert</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
            <span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  
            <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mh">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>  
                <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">toInsert</span><span class="p">);</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">||</span> <span class="n">compare</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                     <span class="k">break</span><span class="p">;</span>  
                <span class="p">}</span>  
                <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">];</span>  
            <span class="p">}</span>

            <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">toInsert</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<h1 id="3">3. 冒泡排序</h1>
<p>冒泡排序可以算是最经典的排序算法了，记得小弟上学时最先接触的也就是这个算法了，因为实现方法最简单，两层 for 循环，里层循环中判断相邻两个元素是否逆序，是的话将两个元素交换，外层循环一次，就能将数组中剩下的元素中最小的元素“浮”到最前面，所以称之为冒泡排序。</p>
<p>照例举个简单的实例吧：</p>
<blockquote>
<p>初始状态：   [24, 19, 26, 39, 36, 7, 31, 29, 38, 23]</p>
<p>内层第一趟： [24, 19, 26, 39, 36, 7, 31, 29, 23 , 38 ] （ 9th [23]&lt;-&gt;8th [38 ）</p>
<p>内层第二趟： [24, 19, 26, 39, 36, 7, 31, 23 , 29 , 38] （ 8th [23]&lt;-&gt;7th [29] ）</p>
<p>内层第三趟： [24, 19, 26, 39, 36, 7, 23 , 31 , 29, 38] （ 7th [23]&lt;-&gt;6th [31] ）</p>
<p>内层第四趟： [24, 19, 26, 39, 36, 7, 23, 31, 29, 38] （ 7 、 23 都位于正确的顺序，无需交换）</p>
<p>内层第五趟： [24, 19, 26, 39, 7 , 36 , 23, 31, 29, 38] （ 5th [7]&lt;-&gt;4th [36] ）</p>
<p>内层第六趟： [24, 19, 26, 7 , 39 , 36, 23, 31, 29, 38] （ 4th [7]&lt;-&gt;3rd [39] ）</p>
<p>内层第七趟： [24, 19, 7 , 26 , 39, 36, 23, 31, 29, 38] （ 3rd [7]&lt;-&gt;2nd [26] ）</p>
<p>内层第八趟： [24, 7 , 19 , 26, 39, 36, 23, 31, 29, 38] （ 2nd [7]&lt;-&gt;1st [19] ）</p>
<p>内层第九趟： [7 , 24 , 19, 26, 39, 36, 23, 31, 29, 38] （ 1st [7]&lt;-&gt;0th [24] ）</p>
<p>…...</p>
</blockquote>
<p>其实冒泡排序跟选择排序比较相像，比较次数一样，都为 n * (n + 1) / 2 ，但是冒泡排序在挑选最小值的过程中会进行额外的交换（冒泡排序在排序中只要发现相邻元素的顺序不对就会进行交换，与之对应的是选择排序，只会在内层循环比较结束之后根据情况决定是否进行交换），所以在我看来，选择排序属于冒泡排序的改进版。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Bubble Sorting, it's very similar with Insertion Sorting </span>
<span class="cm"> */</span>  
<span class="no">BUBBLE</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>  
        <span class="k">int</span> <span class="n">lastExchangedIdx</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>  
        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
            <span class="c1">// mark the flag to identity whether exchange happened to false  </span>
            <span class="n">boolean</span> <span class="n">isExchanged</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>  
            <span class="c1">// last compare and exchange happened before reaching index i  </span>
            <span class="k">int</span> <span class="n">currOrderedIdx</span> <span class="o">=</span> <span class="n">lastExchangedIdx</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">?</span> <span class="n">lastExchangedIdx</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>  
            <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mh">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">currOrderedIdx</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>  
                <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">!=</span> <span class="mh">0</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span> <span class="o">&gt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                    <span class="n">exchange</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>  
                    <span class="n">isExchanged</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>  
                    <span class="n">lastExchangedIdx</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>  
                <span class="p">}</span>  
            <span class="p">}</span>  
            <span class="c1">// if no exchange happen means array is already in order  </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isExchanged</span> <span class="o">==</span> <span class="n">false</span><span class="p">)</span> <span class="p">{</span>  
                <span class="k">break</span><span class="p">;</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<h1 id="4">4. 希尔排序</h1>
<p>希尔排序的诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题。希尔排序的思想是将一个大的数组“分而治之”，划分为若干个小的数组，以 gap 来划分，比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组（对应的，如 gap = 3 ，则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6] ）然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，直至 gap = 1 ，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，解决了插入排序在处理大规模数组时较多移动次数的问题。</p>
<p>具体实例请参照插入排序。</p>
<p>希尔排序是插入排序的改进版，在数据量大的时候对效率的提升帮助很大，数据量小的时候建议直接使用插入排序就好了。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Shell Sorting </span>
<span class="cm"> */</span>  
<span class="no">SHELL</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>  
        <span class="k">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="mh">1</span><span class="p">;</span>

        <span class="c1">// use the most next to length / 3 as the first gap  </span>
        <span class="k">while</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">/</span> <span class="mh">3</span><span class="p">)</span> <span class="p">{</span>  
            <span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span> <span class="o">*</span> <span class="mh">3</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span>  
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&gt;=</span> <span class="mh">1</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
                <span class="no">T</span> <span class="n">next</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
                <span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  
                <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">gap</span><span class="p">)</span> <span class="p">{</span>  
                    <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>  
                    <span class="c1">// already find its position  </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">||</span> <span class="n">compare</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                        <span class="k">break</span><span class="p">;</span>  
                    <span class="p">}</span>

                    <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">];</span>  
                    <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span><span class="p">;</span>  
                <span class="p">}</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>  
                    <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>  
                <span class="p">}</span>  
            <span class="p">}</span>  
            <span class="n">gap</span> <span class="o">/=</span> <span class="mh">3</span><span class="p">;</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<h1 id="5">5. 归并排序</h1>
<p>归并排序采用的是递归来实现，属于“分而治之”，将目标数组从中间一分为二，之后分别对这两个数组进行排序，排序完毕之后再将排好序的两个数组“归并”到一起，归并排序最重要的也就是这个“归并”的过程，归并的过程中需要额外的跟需要归并的两个数组长度一致的空间，比如需要规定的数组分别为： [3, 6, 8, 11] 和 [1, 3, 12, 15] （虽然逻辑上被划为为两个数组，但实际上这些元素还是位于原来数组中的，只是通过一些 index 将其划分成两个数组，原数组为 [3, 6, 8, 11, 1, 3, 12, 15 ，我们设置三个指针 lo, mid, high 分别为 0,3,7 就可以实现逻辑上的子数组划分）那么需要的额外数组的长度为 4 + 4 = 8 。归并的过程可以简要地概括为如下：</p>
<p>1） 将两个子数组中的元素复制到新数组 copiedArray 中，以前面提到的例子为例，则 copiedArray = [3, 6, 8, 11, 1, 3, 12, 15] ；
2） 设置两个指针分别指向原子数组中对应的第一个元素，假定这两个指针取名为 leftIdx 和 rightIdx ，则 leftIdx = 0 （对应 copiedArray 中的第一个元素 [3] ）， rightIdx = 4 （对应 copiedArray 中的第五个元素 [1] ）；
3） 比较 leftIdx 和 rightIdx 指向的数组元素值，选取其中较小的一个并将其值赋给原数组中对应的位置 i ，赋值完毕后分别对参与赋值的这两个索引做自增 1 操作，如果 leftIdx 或 rigthIdx 值已经达到对应数组的末尾，则余下只需要将剩下数组的元素按顺序 copy 到余下的位置即可。
下面给个归并的具体实例：</p>
<blockquote>
<p>第一趟：</p>
<p>辅助数组 [21 , 28, 39 | 35, 38] （数组被拆分为左右两个子数组，以 | 分隔开）</p>
<p>[21 ,  ,  ,  ,  ] （第一次 21 与 35 比较 , 左边子数组胜出， leftIdx = 0 ， i = 0 ）</p>
<p>第二趟：</p>
<p>辅助数组 [21, 28 , 39 | 35, 38]</p>
<p>[21 , 28,  ,  ,  ] （第二次 28 与 35 比较，左边子数组胜出， leftIdx = 1 ， i = 1 ）</p>
<p>第三趟： [21, 28, 39 | 35 , 38]</p>
<p>[21 , 28 , 35,  ,  ] （第三次 39 与 35 比较，右边子数组胜出， rightIdx = 0 ， i = 2 ）</p>
<p>第四趟： [21, 28, 39 | 35, 38 ]</p>
<p>[21 , 28 , 35 , 38,  ] （第四次 39 与 38 比较，右边子数组胜出， rightIdx = 1 ， i = 3 ）</p>
<p>第五趟： [21, 28, 39 | 35, 38]</p>
<p>[21 , 28 , 35 , 38 , 39] （第五次时右边子数组已复制完，无需比较 leftIdx = 2 ， i = 4 ）</p>
</blockquote>
<p>以上便是一次归并的过程，我们可以将整个需要排序的数组做有限次拆分（每次一分为二）直到分为长度为 1 的小数组为止，长度为 1 时数组已经不用排序了。在这之后再逆序（由于采用递归）依次对这些数组进行归并操作，直到最后一次归并长度为 n / 2 的子数组，归并完成之后数组排序也完成。</p>
<p>归并排序需要的额外空间是所有排序中最多的，每次归并需要与参与归并的两个数组长度之和相同个元素（为了提供辅助数组）。则可以推断归并排序的空间复杂度为 1 + 2 + 4 + … + n = n * ( n + 2) / 4 （忽略了 n 的奇偶性的判断），时间复杂度比较难估，这里小弟也忘记是多少了（囧）。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Merge sorting </span>
<span class="cm"> */</span>  
<span class="no">MERGE</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">this</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mh">1</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
    <span class="p">}</span>

    <span class="n">private</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="k">int</span> <span class="n">lo</span><span class="p">,</span> <span class="k">int</span> <span class="n">hi</span><span class="p">,</span>  <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="c1">// OPTIMIZE ONE  </span>
        <span class="c1">// if the substring's length is less than 20,  </span>
        <span class="c1">// use insertion sort to reduce recursive invocation  </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="mh">20</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
                <span class="no">T</span> <span class="n">toInsert</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
                <span class="k">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  
                <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">lo</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>  
                    <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">toInsert</span><span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">||</span> <span class="n">compare</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                        <span class="k">break</span><span class="p">;</span>  
                    <span class="p">}</span>  
                    <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mh">1</span><span class="p">];</span>  
                <span class="p">}</span>

                <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">toInsert</span><span class="p">;</span>  
            <span class="p">}</span>

            <span class="k">return</span><span class="p">;</span>  
        <span class="p">}</span>

        <span class="k">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mh">2</span><span class="p">;</span>  
        <span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
        <span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mh">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
        <span class="n">merge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
    <span class="p">}</span>

    <span class="n">private</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">merge</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="k">int</span> <span class="n">lo</span><span class="p">,</span> <span class="k">int</span> <span class="n">mid</span><span class="p">,</span> <span class="k">int</span> <span class="n">hi</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="c1">// OPTIMIZE TWO  </span>
        <span class="c1">// if it is already in right order, skip this merge  </span>
        <span class="c1">// since there's no need to do so  </span>
        <span class="k">int</span> <span class="n">leftEndCompareToRigthStart</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mh">1</span><span class="p">]);</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">leftEndCompareToRigthStart</span> <span class="o">==</span> <span class="mh">0</span> <span class="o">||</span> <span class="n">leftEndCompareToRigthStart</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">return</span><span class="p">;</span>  
        <span class="p">}</span>

        <span class="p">@</span><span class="n">SuppressWarnings</span><span class="p">(</span><span class="s">"unchecked"</span><span class="p">)</span>  
        <span class="no">T</span><span class="p">[]</span> <span class="n">arrayCopy</span> <span class="o">=</span> <span class="p">(</span><span class="no">T</span><span class="p">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mh">1</span><span class="p">];</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">arraycopy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">arrayCopy</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="n">arrayCopy</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

        <span class="k">int</span> <span class="n">lowIdx</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span>  
        <span class="k">int</span> <span class="n">highIdx</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">if</span> <span class="p">(</span><span class="n">lowIdx</span> <span class="o">&gt;</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="p">{</span>  
                <span class="c1">// left sub array exhausted  </span>
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrayCopy</span><span class="p">[</span><span class="n">highIdx</span><span class="o">++</span><span class="p">];</span>  
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">highIdx</span> <span class="o">&gt;</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="p">{</span>  
                <span class="c1">// right sub array exhausted  </span>
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrayCopy</span><span class="p">[</span><span class="n">lowIdx</span><span class="o">++</span><span class="p">];</span>  
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arrayCopy</span><span class="p">[</span><span class="n">lowIdx</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">arrayCopy</span><span class="p">[</span><span class="n">highIdx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrayCopy</span><span class="p">[</span><span class="n">lowIdx</span><span class="o">++</span><span class="p">];</span>  
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arrayCopy</span><span class="p">[</span><span class="n">highIdx</span><span class="o">++</span><span class="p">];</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<h1 id="6">6. 快速排序</h1>
<p>快速排序也是用归并方法实现的一个“分而治之”的排序算法，它的魅力之处在于它能在每次partition（排序算法的核心所在）都能为一个数组元素确定其排序最终正确位置（一次就定位准，下次循环就不考虑这个元素了）。</p>
<p>快速排序的partition操作按以下逻辑进行，假定本次排序的数组为arr：</p>
<p>1） 选择一个元素（为了简单起见，就选择本次partition的第一个元素，即arr[0]）作为基准元素，接下来的步骤会为其确定排序完成后最终的位置；</p>
<p>2） 1）  接下来需要遍历[1…n-1]对应的数组元素以帮助找到arr[0]值（以v替代）对应的位置，定义i为当前访问数组的索引，lt为值小于v的最大索引，gt为值大于v的最小索引，那么在遍历过程中，如果发现i指向的值与v相等，则将i值加1，继续下一次比较；如果i指向的值比v小，则将i和lt对应的元素进行交换，然后分别将两个索引加1；如果i指向的值比v大，则将i与gt对应的元素进行交换，然后i自增，gt自减。循环遍历完成（i &gt; gt时结束）之后可以保证[0…lt-1]对应的值都是比v小的，[lt..gt]之间的值都是与v相等的，[gt+1…n-1]对应的值都是比v大的。</p>
<p>3） 分别对[0…lt-1]和[gt+1…n-1]两个子数组进行排序，如此递归，直至子子子数组的长度为0。</p>
<p>下面举个partition的具体实例：</p>
<blockquote>
<p>初始（i = 1, lt = 0, gt = 8）：</p>
<p>[41, 59, 43, 26, 63, 30, 29, 26, 42]（需要确定位置的为0th[41]）</p>
<p>第一趟（i = 1, lt = 0, gt = 8）：</p>
<p>[41, 42, 43, 26, 63, 30, 29, 26, 59]（1st[59] &gt; 41，1st[59]&lt;-&gt;8th[42]，gt--）</p>
<p>第二趟（i = 1, lt = 0, gt = 7）：</p>
<p>[41, 26, 43, 26, 63, 30, 29, 42, 59]（1st[42] &gt; 41，1st[42]&lt;-&gt;7th[26]，gt--）</p>
<p>第三趟（i = 1, lt = 0, gt = 6）：</p>
<p>[26, 41, 43, 26, 63, 30, 29, 42, 59]（1st[26] &lt; 41, 1st[26]&lt;-&gt;0st[41]，i++, lt++）</p>
<p>第四趟（i = 2, lt = 1, gt = 6）：</p>
<p>[26, 41, 29, 26, 63, 30, 43, 42, 59]（2nd[43] &gt; 41，2nd[43]&lt;-&gt;6th[29]，gt--）</p>
<p>第五趟（i = 2, lt = 1, gt = 5）：</p>
<p>[26, 29, 41, 26, 63, 30, 43, 42, 59]（2nd[29] &lt; 41, 2nd[29]&lt;-&gt;1st[41]，i++，lt++）</p>
<p>第六趟（i = 3, lt = 2, gt = 5）：    </p>
<p>[26, 29, 26, 41, 63, 30, 43, 42, 59]（3rd[26] &lt; 41，3rd[26]&lt;-&gt;2nd[41]，i++，lt++）</p>
<p>第七趟（i = 4, lt = 3, gt = 5）：</p>
<p>[26, 29, 26, 41, 30, 63, 43, 42, 59] （4th[63] &gt; 41，4th[63]&lt;-&gt;5th[30]，gt--）</p>
<p>第八趟（i = 4, lt = 3, gt = 4）：    </p>
<p>[26, 29, 26, 30, 41, 63, 43, 42, 59]（4th[30] &lt; 41，4th[30]&lt;-&gt;3rd[41]，i++，lt++）</p>
</blockquote>
<p>可以看出，在一次partition之后，以41为分割线，41左侧皆为比它小的元素，41右侧皆为比它大或相等的元素（当然这个实例比较特殊，没有出现和41相等的元素）。快速排序顾名思义就是排序速度非常快，后面我会放在我机器上跑各个排序方法的时间对比图。值得一提的是JDK中在Arrays工具内中内置的sort方法就是接合插入排序和三路快速排序实现的，有兴趣的同学可以看看JDK的源码。</p>
<p>实现代码：</p>
<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * Quick Sorting </span>
<span class="cm"> */</span>  
<span class="no">QUICK</span><span class="p">(</span><span class="k">new</span> <span class="n">Sortable</span><span class="p">()</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">this</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mh">0</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mh">1</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
    <span class="p">}</span>

    <span class="n">private</span> <span class="o">&lt;</span><span class="no">T</span> <span class="k">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="k">void</span> <span class="n">sort</span><span class="p">(</span><span class="no">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="k">int</span> <span class="n">lo</span><span class="p">,</span> <span class="k">int</span> <span class="n">hi</span><span class="p">,</span> <span class="n">boolean</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">return</span><span class="p">;</span>  
        <span class="p">}</span>

        <span class="no">T</span> <span class="n">toFinal</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">lo</span><span class="p">];</span>  
        <span class="k">int</span> <span class="n">leftIdx</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>  
        <span class="k">int</span> <span class="n">rightIdx</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>

        <span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mh">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rightIdx</span><span class="p">)</span> <span class="p">{</span>  
            <span class="k">int</span> <span class="n">compare</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">toFinal</span><span class="p">);</span>  
            <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">==</span> <span class="mh">0</span><span class="p">)</span> <span class="p">{</span>  
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>  
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="o">&lt;</span> <span class="mh">0</span> <span class="o">==</span> <span class="n">ascend</span><span class="p">)</span> <span class="p">{</span>  
                <span class="n">exchange</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">leftIdx</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>  
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
                <span class="n">exchange</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">rightIdx</span><span class="o">--</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
            <span class="p">}</span>  
        <span class="p">}</span>

        <span class="c1">// partially sort left array and right array  </span>
        <span class="c1">// no need to include the leftIdx-th to rightIdx-th elements  </span>
        <span class="c1">// since they are already in its final position  </span>
        <span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">leftIdx</span> <span class="o">-</span> <span class="mh">1</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
        <span class="n">sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">rightIdx</span> <span class="o">+</span> <span class="mh">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">ascend</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">})</span>
</pre></div>
<p>这里是我测试时的测试用例，利用了枚举和策略模式的优势，切换排序算法时相对会比较容易。</p>
<p>以下为经典排序算法在我机器上运行的耗时对比图（测试用的随机数组长度为50000），直接截的测试用例的图。</p>
<p><img alt="" src="\images\排序测试.png"/></p>
            <section>
    <p id="post-share-links">
    Share on:
    <a href="http://twitter.com/home?status=%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%20 http%3A//www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/" target="_blank" title="Share on Twitter">Twitter</a>
    ❄
    <a href="http://www.facebook.com/sharer/sharer.php?s=100&p[url]=http%3A//www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/&p[images][0]=&p[title]=%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%20&p[summary]=%0A%3Cp%3E%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BE%88%E5%A4%9A%E5%9C%B0%E6%96%B9%E9%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%8C%E8%BF%91%E6%9C%9F%E5%8F%88%E9%87%8D%E6%96%B0%E7%9C%8B%E4%BA%86%E4%B8%80%E9%81%8D%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E8%87%AA%E5%B7%B1%E7%AE%80%E5%8D%95%E5%9C%B0%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%B8%80%E9%81%8D%EF%BC%8C%E7%89%B9%E6%AD%A4%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%EF%BC%8C%E4%B8%BA%E4%BB%A5%E5%90%8E%E5%A4%8D%E4%B9%A0%E7%95%99%E7%82%B9%E6%9D%90%E6%96%99%E3%80%82%3C/p%3E%0A%3Cp%3E%E5%BA%9F%E8%AF%9D%E4%B8%8D%E5%A4%9A%E8%AF%B4%EF%BC%8C%E4%B8%8B%E9%9D%A2%E9%80%90%E4%B8%80%E7%9C%8B%E7%9C%8B%E7%BB%8F%E5%85%B8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%3C/p%3E%0A%3Ch1%20id%3D%221%22%3E1.%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%3C/h1%3E%0A%3Cp%3E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%98%AF%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BB%A5%20i%20%E4%BB%A3%E8%A1%A8%E5%BD%93%E5%89%8D%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%8F%E5%8F%B7%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E5%9C%A8%E5%89%A9%E4%BD%99%E7%9A%84%20%5Bi%E2%80%A6n-1%5D%20%E4%B8%AD%E6%89%BE%E5%87%BA%E5%85%B6%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E6%89%BE%E5%88%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B8%8E%20i%20%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2%E3%80%82%E5%9B%A0%E4%B8%BA%E6%AF%8F%E4%B8%80%E8%B6%9F%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E9%80%89%E6%8B%A9%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BA%BA%E4%BB%AC%E5%BD%A2%E8%B1%A1%E5%9C%B0%E7%A7%B0%E4%B9%8B%E4%B8%BA%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%82%3C/p%3E%0A%3Cp%3E%E4%B8%BE%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%9D%A5%E7%9C%8B%E7%9C%8B%EF%BC%9A%3C/p%3E%0A%3Cblockquote%3E%0A%3Cp%3E%E5%88%9D%E5%A7%8B%EF%BC%9A%20%5B38%2C%2017%2C%2016%2C%2016%2C%207%2C%2031%2C%2039%2C%2032%2C%202%2C%2011%5D%3C/p%3E%0A%3Cp%3Ei%20%3D%200%3A%20%20%5B2%20%2C%2017%2C%2016%2C%2016%2C%207%2C%2031%2C%2039%2C%2032%2C%2038%20%2C%2011%5D%20%280th%20%5B38%5D%26lt%3B-%26gt%3B8th%20%5B2%20...%3C/p%3E%3C/blockquote%3E" target="_blank" title="Share on Facebook">Facebook</a>
    ❄
    <a href="https://plus.google.com/share?url=http%3A//www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/" target="_blank" title="Share on Google Plus">Google+</a>
    ❄
    <a href="mailto:?subject=%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%20&body=http%3A//www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/" target="_blank" title="Share via Email">Email</a>
    </p>
</section>

            <section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'zsczsc';
        var disqus_identifier = 'http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/';
    var disqus_url = 'http://www.zscbb.com/posts/2013/05/chang-yong-pai-xu-suan-fa-xiao-ji/';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>
<section>
    <h2>Related Posts</h2>
<ul class="related-posts-list">
<li><a href="http://www.zscbb.com/posts/2014/03/zhuan-zhu-zai-ji-suan-ji-de-10ge-suan-fa/" title="[转]主宰计算机的10个算法">[转]主宰计算机的10个算法</a></li>
<li><a href="http://www.zscbb.com/posts/2015/04/115ge-javamian-shi-ti-he-da-an-zhong-ji-lie-biao-shang/" title="115个Java面试题和答案——终极列表（上）">115个Java面试题和答案——终极列表（上）</a></li>
</ul>
<hr />
</section>
            <aside>
            <nav>
            <ul class="articles-timeline">
                <li class="previous-article">« <a href="http://www.zscbb.com/posts/2011/08/build-rand3-from-rand5/" title="Previous: 利用等概率Rand5产生等概率Rand3">利用等概率Rand5产生等概率Rand3</a></li>
                <li class="next-article"><a href="http://www.zscbb.com/posts/2013/12/python-read-write-excel/" title="Next: 用Python读写Excel文件">用Python读写Excel文件</a> »</li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2013-05-21T00:00:00">May 21, 2013</time>
            <h4>Category</h4>
            <a class="category-link" href="http://www.zscbb.com/categories.html#suan-fa-ref">算法</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="http://www.zscbb.com/tags.html#java-ref">Java
                    <span>2</span>
</a></li>
                <li><a href="http://www.zscbb.com/tags.html#suan-fa-ref">算法
                    <span>2</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="mailto:zsc846551675@126.com" title="My email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
    <a href="https://github.com/JustinCheung" title="My Github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="http://weibo.com/1308577680" title="My Weibo Profile Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-weibo profile sidebar-social-links"></i></a>
    <a href="https://www.facebook.com/justin.cheung.790256" title="My facebook Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-facebook sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

            <script type="text/javascript">
var disqus_shortname = 'zsczsc';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementsByClassName('accordion-toggle');
    var old_innerHTML = link[0].innerHTML;
    $(link[0]).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link[0]).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>


    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>